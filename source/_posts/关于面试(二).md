---
layout: post
title: 关于面试(二)
date: 2019.7.19
body: [article,  comments]
sidebar: false
tag: [Android,面试]
categories: [Android]
top: true
---
#### view的绘制流程
Android的UI管理系统层级关系
![](https://coolyun1.oss-cn-shenzhen.aliyuncs.com/20190719141337.png)
    View的绘制过程是从ViewRoot的performTraversals方法开始的，在其内部依次调用View的performMeasure,performLayout,performDraw三个方法。这三个方法分别完成顶级View的measure,layout,draw过程。其中，performMeasure中会调用measure方法，而在measure方法中又会调用onMeausre()方法，然后在onMeaure方法中会对所有的子元素进行measure过程，这时measure流程就从父容器传递到了子元素中，子元素会继续重复父容器的measure过程，如此反复即完成了整个View树结构的遍历，最终 完成View的测量过程。
<!-- more -->
    同理，performLayout和performDraw方法的传递流程和performMeasure类似，但不同的是，performDraw的传递是在draw方法中通过dispatchDraw方法来下发的，不过本质上原理还是一样的。下面给出一张流程图方便大家更好的理解：
![](https://coolyun1.oss-cn-shenzhen.aliyuncs.com/20190719141403.png)
只看一下主要几个方法:
1. performMeasure

```
private void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) {
        Trace.traceBegin(Trace.TRACE_TAG_VIEW, "measure");
        try {
            mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);
        } finally {
            Trace.traceEnd(Trace.TRACE_TAG_VIEW);
        }
    }
```

```
public final void measure(int widthMeasureSpec, int heightMeasureSpec) {
         // 调用onMeasure()
         onMeasure(widthMeasureSpec, heightMeasureSpec); 
    }
```

```
@Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        if (mOrientation == VERTICAL) {
            // 我们以垂直为例
            measureVertical(widthMeasureSpec, heightMeasureSpec);
        } else {
            measureHorizontal(widthMeasureSpec, heightMeasureSpec);
        }
    }
```

```
void measureVertical(int widthMeasureSpec, int heightMeasureSpec) {
        // See how tall everyone is. Also remember max width.
        for (int i = 0; i < count; ++i) {
            final View child = getVirtualChildAt(i);
            // 测量子孩子
            measureChildBeforeLayout(child, i, widthMeasureSpec, 0,
                        heightMeasureSpec, usedHeight);

            final int childHeight = child.getMeasuredHeight();

            final int totalLength = mTotalLength;
            // 高度是子View的高度不断的叠加
            mTotalLength = Math.max(totalLength, totalLength + childHeight + lp.topMargin +
                       lp.bottomMargin + getNextLocationOffset(child));
        }
        int heightSize = mTotalLength;
        // Check against our minimum height
        heightSize = Math.max(heightSize, getSuggestedMinimumHeight());
        
        // Reconcile our calculated size with the heightMeasureSpec
        int heightSizeAndState = resolveSizeAndState(heightSize, heightMeasureSpec, 0);
        // 设置宽高
        setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState),
                heightSizeAndState);
    }
```
ViewGroup在调用onMeasure()方法的时候,会不断的循环测量子view.

```
void measureChildBeforeLayout(View child, int childIndex,
            int widthMeasureSpec, int totalWidth, int heightMeasureSpec,
            int totalHeight) {
        measureChildWithMargins(child, widthMeasureSpec, totalWidth,
                heightMeasureSpec, totalHeight);
    }
```

```
protected void measureChildWithMargins(View child,
            int parentWidthMeasureSpec, int widthUsed,
            int parentHeightMeasureSpec, int heightUsed) {
        final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();
        //  getChildMeasureSpec 这个方法非常关键
        final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,
                mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin
                        + widthUsed, lp.width);
        final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,
                mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin
                        + heightUsed, lp.height);

        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
    }
```
三种测量方式:
![](https://coolyun1.oss-cn-shenzhen.aliyuncs.com/20190719141441.png)

```
public static int getChildMeasureSpec(int spec, int padding, int childDimension) {
        //获取当前Parent View的Mode和Size
        int specMode = MeasureSpec.getMode(spec);
        int specSize = MeasureSpec.getSize(spec);
        //获取Parent size与padding差值（也就是Parent剩余大小），若差值小于0直接返回0
        int size = Math.max(0, specSize - padding);
        //定义返回值存储变量
        int resultSize = 0;
        int resultMode = 0;
        //依据当前Parent的Mode进行switch分支逻辑
        switch (specMode) {
        // Parent has imposed an exact size on us
        case MeasureSpec.EXACTLY:
            if (childDimension >= 0) {
                //如果child的layout_w和h属性在xml或者java中给予具体大于等于0的数值
                //设置child的size为真实layout_w和h属性值，mode为EXACTLY
                resultSize = childDimension;
                resultMode = MeasureSpec.EXACTLY;
            } else if (childDimension == LayoutParams.MATCH_PARENT) {
                // Child wants to be our size. So be it.
                //如果child的layout_wOrh属性在xml或者java中给予MATCH_PARENT
                //设置child的size为size，mode为EXACTLY
                resultSize = size;
                resultMode = MeasureSpec.EXACTLY;
            } else if (childDimension == LayoutParams.WRAP_CONTENT) {
                // Child wants to determine its own size. It can't be
                // bigger than us.
                //如果child的layout_wOrh属性在xml或者java中给予WRAP_CONTENT
                //设置child的size为size，mode为AT_MOST
                resultSize = size;
                resultMode = MeasureSpec.AT_MOST;
            }
            break;

        // Parent has imposed a maximum size on us
        case MeasureSpec.AT_MOST:
            if (childDimension >= 0) {
                // ......
            } else if (childDimension == LayoutParams.MATCH_PARENT) {
                // Child wants to be our size, but our size is not fixed.
                // Constrain child to not be bigger than us.
                // 如果父 View 是 AT_MOST 就算子 View 是 MATCH_PARENT，
                // 其实子View获得的测量模式还是AT_MOST
                resultSize = size;
                resultMode = MeasureSpec.AT_MOST;
            } else if (childDimension == LayoutParams.WRAP_CONTENT) {
                // Child wants to determine its own size. It can't be
                // bigger than us.
                resultSize = size;
                resultMode = MeasureSpec.AT_MOST;
            }
            break;

            // ......
        }
        //noinspection ResourceType
        return MeasureSpec.makeMeasureSpec(resultSize, resultMode);
    }
```
View的绘制流程第一步是onMeasure()，该方法用来测量和指定布局到底占多大的宽高，因为控件的宽高是由父布局和本身来决定的，所以测量是不断的往内走，而最终确定宽高是由内不断的往外走，是递归的方式。
2. performLayout

```
private void performLayout(WindowManager.LayoutParams lp, int desiredWindowWidth,
            int desiredWindowHeight) {
        final View host = mView;
        // 调用layout()方法
        host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight());
    }

    public void layout(int l, int t, int r, int b) {
        onLayout(changed, l, t, r, b);
    }
```

```
@Override
    protected void onLayout(boolean changed, int l, int t, int r, int b) {
        if (mOrientation == VERTICAL) {
            // 我们以垂直为例
            layoutVertical(l, t, r, b);
        } else {
            layoutHorizontal(l, t, r, b);
        }
    }
```

```
void layoutVertical(int left, int top, int right, int bottom) {
        final int paddingLeft = mPaddingLeft;

        int childTop;
        int childLeft;

        // Where right end of child should go
        //计算父窗口推荐的子View宽度
        final int width = right - left;
        //计算父窗口推荐的子View右侧位置
        int childRight = width - mPaddingRight;

        // Space available for child
        //child可使用空间大小
        int childSpace = width - paddingLeft - mPaddingRight;
        //通过ViewGroup的getChildCount方法获取ViewGroup的子View个数
        final int count = getVirtualChildCount();
        //获取Gravity属性设置
        final int majorGravity = mGravity & Gravity.VERTICAL_GRAVITY_MASK;
        final int minorGravity = mGravity & Gravity.RELATIVE_HORIZONTAL_GRAVITY_MASK;
        //依据majorGravity计算childTop的位置值
        switch (majorGravity) {
           case Gravity.BOTTOM:
               // mTotalLength contains the padding already
               childTop = mPaddingTop + bottom - top - mTotalLength;
               break;

               // mTotalLength contains the padding already
           case Gravity.CENTER_VERTICAL:
               childTop = mPaddingTop + (bottom - top - mTotalLength) / 2;
               break;

           case Gravity.TOP:
           default:
               childTop = mPaddingTop;
               break;
        }
        //重点！！！开始遍历
        for (int i = 0; i < count; i++) {
            final View child = getVirtualChildAt(i);
            if (child == null) {
                childTop += measureNullChild(i);
            } else if (child.getVisibility() != GONE) {
                //LinearLayout中其子视图显示的宽和高由measure过程来决定的，因此measure过程的意义就是为layout过程提供视图显示范围的参考值
                final int childWidth = child.getMeasuredWidth();
                final int childHeight = child.getMeasuredHeight();
                //获取子View的LayoutParams
                final LinearLayout.LayoutParams lp =
                        (LinearLayout.LayoutParams) child.getLayoutParams();

                int gravity = lp.gravity;
                if (gravity < 0) {
                    gravity = minorGravity;
                }
                final int layoutDirection = getLayoutDirection();
                final int absoluteGravity = Gravity.getAbsoluteGravity(gravity, layoutDirection);
                //依据不同的absoluteGravity计算childLeft位置
                switch (absoluteGravity & Gravity.HORIZONTAL_GRAVITY_MASK) {
                    case Gravity.CENTER_HORIZONTAL:
                        childLeft = paddingLeft + ((childSpace - childWidth) / 2)
                                + lp.leftMargin - lp.rightMargin;
                        break;

                    case Gravity.RIGHT:
                        childLeft = childRight - childWidth - lp.rightMargin;
                        break;

                    case Gravity.LEFT:
                    default:
                        childLeft = paddingLeft + lp.leftMargin;
                        break;
                }

                if (hasDividerBeforeChildAt(i)) {
                    childTop += mDividerHeight;
                }

                childTop += lp.topMargin;
                //通过垂直排列计算调运child的layout设置child的位置
                setChildFrame(child, childLeft, childTop + getLocationOffset(child),
                        childWidth, childHeight);
                childTop += childHeight + lp.bottomMargin + getNextLocationOffset(child);

                i += getChildrenSkipCount(child, i);
            }
        }
    }
```
从上面分析可以看出layout也是从顶层父View向子View的递归调用view.layout方法的过程，即父View根据第一步performMeasure，来获取子View所的布局大小和布局参数，将子View放在合适的位置上，不过这个方法没有再往外走，只是不断的往里面走。
3. performDraw

```
private void performDraw() {
        try {
            draw(fullRedrawNeeded);
        } finally {
            mIsDrawing = false;
            Trace.traceEnd(Trace.TRACE_TAG_VIEW);
        }
    }

    private void draw(boolean fullRedrawNeeded) {
        Surface surface = mSurface;
        if (!surface.isValid()) {
            return;
        }
        
        if (!drawSoftware(surface, mAttachInfo, xOffset, yOffset, scalingRequired, dirty)) {
            return;
        }
    }

    private boolean drawSoftware(Surface surface, AttachInfo attachInfo, int xoff, int yoff,
            boolean scalingRequired, Rect dirty) {
        // Draw with software renderer.
        final Canvas canvas;
        final int left = dirty.left;
        final int top = dirty.top;
        final int right = dirty.right;
        final int bottom = dirty.bottom;
        canvas = mSurface.lockCanvas(dirty);
        // ... ...
        mView.draw(canvas);
    }
```
#### 事件分发
1. 事件类型(down,up,move,cancel),从手指借出屏幕到手指离开屏幕为一组事件
![](https://coolyun1.oss-cn-shenzhen.aliyuncs.com/20190719141523.png)
2. 事件分发的本质就是将点击事件传递到某个具体的view&处理的整个过程.
3. 事件在Activity,ViewGroup,View中传递
4. 事件分发由哪些方法协作完成
![](https://coolyun1.oss-cn-shenzhen.aliyuncs.com/20190719141541.png)
5. activity的事件分发:
![](https://coolyun1.oss-cn-shenzhen.aliyuncs.com/20190719141600.png)
![](https://coolyun1.oss-cn-shenzhen.aliyuncs.com/20190719141630.png)
6. ViewGroup的事件分发:
![](https://coolyun1.oss-cn-shenzhen.aliyuncs.com/20190719141645.png)
7. View的事件分发:
![](https://coolyun1.oss-cn-shenzhen.aliyuncs.com/20190719141703.png)
![](https://coolyun1.oss-cn-shenzhen.aliyuncs.com/20190719141725.png)
8. 总结
![](https://coolyun1.oss-cn-shenzhen.aliyuncs.com/20190719141805.png)

#### 测试
从Activity到ViewGroup到View. Activity类中添加一下代码

```
@Override
    public boolean onTouchEvent(MotionEvent event) {
        Log.e("gao", "onTouchEvent: "+this.getClass().getName());
        return super.onTouchEvent(event);
    }

    @Override
    public void onClick(View v) {
        Log.e("gao", "onClick: "+this.getClass().getName());
    }

    @Override
    public boolean dispatchTouchEvent(MotionEvent ev) {
        Log.e("gao", "dispatchTouchEvent: "+this.getClass().getName());
        return super.dispatchTouchEvent(ev);
    }

```
 ViewGroup中添加以下代码:

 
```
@Override
    public boolean dispatchTouchEvent(MotionEvent ev) {
        Log.e("gao", "dispatchTouchEvent: "+this.getClass().getName());
        return super.dispatchTouchEvent(ev);
    }

    @Override
    public boolean onInterceptTouchEvent(MotionEvent ev) {
        Log.e("gao", "onInterceptTouchEvent: "+this.getClass().getName());
        return super.onInterceptTouchEvent(ev);
    }

    @Override
    public boolean onTouchEvent(MotionEvent event) {
        Log.e("gao", "onTouchEvent: "+this.getClass().getName());
        return super.onTouchEvent(event);
    }

```
View中添加以下代码:

```
@Override
    public boolean onTouchEvent(MotionEvent event) {
        Log.e("gao", "onTouchEvent: "+this.getClass().getName());
        return super.onTouchEvent(event);
    }

    @Override
    public boolean dispatchTouchEvent(MotionEvent event) {
        Log.e("gao", "dispatchTouchEvent: "+this.getClass().getName());
        return super.dispatchTouchEvent(event);
    }

```

  默认情况下调用顺序:
  
```
04-17 08:03:09.766 2887-2887/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity
04-17 08:03:09.767 2887-2887/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela
04-17 08:03:09.767 2887-2887/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela
04-17 08:03:09.767 2887-2887/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn
04-17 08:03:09.767 2887-2887/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn
04-17 08:03:09.786 2887-2887/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyRela
04-17 08:03:09.786 2887-2887/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity
04-17 08:03:09.889 2887-2887/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity
04-17 08:03:09.889 2887-2887/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity
```

view中touchEvent改为true

```
04-17 08:06:14.757 2992-2992/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity
04-17 08:06:14.757 2992-2992/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela
04-17 08:06:14.757 2992-2992/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela
04-17 08:06:14.757 2992-2992/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn
04-17 08:06:14.757 2992-2992/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn
04-17 08:06:14.757 2992-2992/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity
04-17 08:06:14.757 2992-2992/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela
04-17 08:06:14.757 2992-2992/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela
04-17 08:06:14.757 2992-2992/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn
04-17 08:06:14.757 2992-2992/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn

```

事件传到View后不再往外传,因为已经被消费了 方法都调用了两遍是因为接收了down事件之后,up事件也传过来接收了

view中touchEvent改为false

```
04-17 08:23:47.369 3622-3622/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity
04-17 08:23:47.370 3622-3622/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela
04-17 08:23:47.370 3622-3622/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela
04-17 08:23:47.370 3622-3622/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn
04-17 08:23:47.370 3622-3622/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn
04-17 08:23:47.370 3622-3622/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyRela
04-17 08:23:47.370 3622-3622/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity
04-17 08:23:47.505 3622-3622/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity
04-17 08:23:47.505 3622-3622/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity

```

View的dispatchTouchEvent改为true

```
04-17 08:26:52.930 3721-3721/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity
04-17 08:26:52.930 3721-3721/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela
04-17 08:26:52.930 3721-3721/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela
04-17 08:26:52.930 3721-3721/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn

```

不再分发,不消费,会接收后续事件

View的dispatchTouchEvent改为false

```
04-17 08:29:02.066 3822-3822/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity
04-17 08:29:02.067 3822-3822/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela
04-17 08:29:02.067 3822-3822/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela
04-17 08:29:02.067 3822-3822/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn
04-17 08:29:02.067 3822-3822/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyRela
04-17 08:29:02.067 3822-3822/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity
04-17 08:29:02.176 3822-3822/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity
04-17 08:29:02.176 3822-3822/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity

```

不再分发.会传给外层布局的onTouchEvent进行消费,如果都不进行消费,则后续事件不再向内分发.

只有View的dispatchTouchEvent为默认值时才会调View的onTouchEvent方法.

ViewGroup中

onTouchEvent返回true


```
04-17 08:42:18.120 4533-4533/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity
04-17 08:42:18.121 4533-4533/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela
04-17 08:42:18.121 4533-4533/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela
04-17 08:42:18.122 4533-4533/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn
04-17 08:42:18.122 4533-4533/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn
04-17 08:42:18.122 4533-4533/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyRela
04-17 08:42:35.925 4533-4533/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity
04-17 08:42:35.925 4533-4533/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela
04-17 08:42:35.925 4533-4533/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyRela
```
消费之后会仍会分发给子类,如果子类不消费,后续事件不再分发给子类.

于此同时把View的onTouchEvent方法改为true

```
04-17 08:44:28.544 4635-4635/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity
04-17 08:44:28.545 4635-4635/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela
04-17 08:44:28.545 4635-4635/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela
04-17 08:44:28.545 4635-4635/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn
04-17 08:44:28.545 4635-4635/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn
04-17 08:44:34.966 4635-4635/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity
04-17 08:44:34.966 4635-4635/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela
04-17 08:44:34.966 4635-4635/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela
04-17 08:44:34.966 4635-4635/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn
04-17 08:44:34.966 4635-4635/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn
```

对ViewGroup的事件消费,且后续事件会传递到View中.

onTouchEvent返回false

```
04-17 08:46:36.068 4735-4735/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity
04-17 08:46:36.068 4735-4735/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela
04-17 08:46:36.068 4735-4735/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela
04-17 08:46:36.068 4735-4735/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn
04-17 08:46:36.068 4735-4735/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn
04-17 08:46:36.068 4735-4735/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyRela
04-17 08:46:36.068 4735-4735/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity
04-17 08:47:04.229 4735-4735/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity
04-17 08:47:04.229 4735-4735/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity

```

不进行消费,当次事件会继续分发,如果子View不进行消费则后续事件不再分发进ViewGroup,如果子View进行消费,则后续事件仍会分发,只是不再经过ViewGroup的OntouchEvent()


```
04-17 08:50:15.560 5023-5023/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity
04-17 08:50:15.560 5023-5023/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela
04-17 08:50:15.560 5023-5023/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela
04-17 08:50:15.560 5023-5023/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn
04-17 08:50:15.560 5023-5023/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn
04-17 08:50:19.491 5023-5023/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity
04-17 08:50:19.491 5023-5023/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela
04-17 08:50:19.491 5023-5023/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela
04-17 08:50:19.491 5023-5023/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn
04-17 08:50:19.491 5023-5023/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn
```
onInterceptTouchEvent返回true

```
04-17 08:53:53.191 5127-5127/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity
04-17 08:53:53.193 5127-5127/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela
04-17 08:53:53.193 5127-5127/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela
04-17 08:53:53.193 5127-5127/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyRela
04-17 08:53:53.193 5127-5127/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity
04-17 08:54:08.389 5127-5127/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity
04-17 08:54:08.389 5127-5127/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity

```
拦截后事件不会据需分发,会调用ViewGroup的OntouchVent,如果不进行消费,后续事件不会分发进来.

与此同时,把onTOuchEvent的返回值改为true

```
04-17 08:56:00.350 5228-5228/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity
04-17 08:56:00.350 5228-5228/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela
04-17 08:56:00.350 5228-5228/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela
04-17 08:56:00.351 5228-5228/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyRela
04-17 08:56:02.535 5228-5228/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity
04-17 08:56:02.535 5228-5228/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela
04-17 08:56:02.535 5228-5228/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyRela
```
拦截之后进行消费,后续事件仍会继续分发,但不再调用拦截方法

把dispatchTouchEvent返回true


```
04-17 09:00:31.695 5428-5428/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity
04-17 09:00:31.695 5428-5428/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela
04-17 09:00:31.813 5428-5428/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity
04-17 09:00:31.814 5428-5428/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela

```
往外分发,仍接收后续事件 改为false

```
04-17 09:02:19.810 5529-5529/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity
04-17 09:02:19.810 5529-5529/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela
04-17 09:02:19.810 5529-5529/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity
04-17 09:02:19.928 5529-5529/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity
04-17 09:02:19.928 5529-5529/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity

```
向外分发,不再接收后续事件,会调用Activity的onTouchEvent()

Activity中

dispatchTouchEvent返回true或false


```
04-17 09:08:04.216 5728-5728/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity
04-17 09:08:04.333 5728-5728/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity

```
onTouchEvent()改为true

```
04-17 09:09:23.950 5931-5931/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity
04-17 09:09:23.950 5931-5931/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela
04-17 09:09:23.951 5931-5931/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela
04-17 09:09:23.951 5931-5931/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn
04-17 09:09:23.951 5931-5931/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn
04-17 09:09:23.951 5931-5931/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyRela
04-17 09:09:23.951 5931-5931/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity
04-17 09:09:24.094 5931-5931/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity
04-17 09:09:24.094 5931-5931/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity

```
当次事件会继续分发,如果没有子控件消费,后续事件不再分发.直接调用onTouchEvent,

于此同时把View中的onTouchEvent方法返回true

```
04-17 09:15:08.467 6031-6031/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity
04-17 09:15:08.467 6031-6031/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela
04-17 09:15:08.467 6031-6031/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela
04-17 09:15:08.467 6031-6031/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn
04-17 09:15:08.467 6031-6031/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn
04-17 09:15:11.154 6031-6031/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity
04-17 09:15:11.154 6031-6031/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela
04-17 09:15:11.154 6031-6031/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela
04-17 09:15:11.154 6031-6031/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn
04-17 09:15:11.154 6031-6031/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn

```
View会先于Activity消费事件,且后续事件会继续分发到View

把Activity的onTouchEvent()置为false,且子类不消费事件,则当次事件继续分发,后续事件不再分发,直接调用Activity的onTouchEvent方法.

#### 参考
[源码解析 - View的绘制流程](https://www.jianshu.com/p/1075d7d521ec)
[Android 自定义View——View的绘制流程](https://www.jianshu.com/p/56006bc13dcf)
[Android事件分发机制详解：史上最全面、最易懂](https://www.jianshu.com/p/38015afcdb58)




