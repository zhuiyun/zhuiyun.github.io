{"meta":{"title":"CoolYun","subtitle":null,"description":null,"author":"CoolYun","url":"http://yoursite.com","root":"/"},"pages":[{"title":"关于","date":"2019-07-19T02:31:42.225Z","updated":"2019-07-11T11:25:21.629Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2019-07-11T11:29:43.731Z","updated":"2019-07-11T11:29:43.713Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2019-07-11T11:28:45.457Z","updated":"2019-07-11T11:28:45.440Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"解决AndroidStudio的命令行乱码","slug":"AndroidStudio命令行乱码","date":"2019-07-30T16:00:00.000Z","updated":"2019-07-31T10:10:39.808Z","comments":true,"path":"2019/07/31/AndroidStudio命令行乱码/","link":"","permalink":"http://yoursite.com/2019/07/31/AndroidStudio命令行乱码/","excerpt":"","text":"#解决AndroidStudio命令行乱码 现象用的macbook,下载了item2后,根据网上博客配置了一些属性,之后打开Androidstudio时,发现命令行乱码,鼓捣了一阵终于搞定 解决这个情况主要是修改了命令行的字体,但Androidstudio中有默认字体,两者不是同一个造成的,只需修改其中之一即可,我改的是Androidstudio.修改位置如下图:需要和item2中字体一致","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"问题解决","slug":"问题解决","permalink":"http://yoursite.com/tags/问题解决/"}]},{"title":"关于面试(一)","slug":"关于面试(一)","date":"2019-07-18T16:00:00.000Z","updated":"2019-07-19T06:12:28.865Z","comments":true,"path":"2019/07/19/关于面试(一)/","link":"","permalink":"http://yoursite.com/2019/07/19/关于面试(一)/","excerpt":"优化篇内存泄漏 内部类隐性的持有外部类的引用导致内存泄漏:常见的如使用handler时,直接new创建对象,当页面关闭时,如果handler还在运行时会持有activity的引用,导致activity得不到释放,从而引起内存泄漏。 解决方法:使用静态内部类,然后用弱引用持有外部类的引用","text":"优化篇内存泄漏 内部类隐性的持有外部类的引用导致内存泄漏:常见的如使用handler时,直接new创建对象,当页面关闭时,如果handler还在运行时会持有activity的引用,导致activity得不到释放,从而引起内存泄漏。 解决方法:使用静态内部类,然后用弱引用持有外部类的引用 静态变量引起的内存泄漏:静态变量的生命周期和应用的生命周期一样长,如果用静态变量引用了某个activity的实例会导致activity得不到释放, 解决方法:将activity的引用改为application的引用 资源对象未关闭:对于使用了BraodcastReceiver，ContentObserver，File，Cursor，Stream，Bitmap等资源的代码，应该在Activity销毁时及时关闭或者注销，否则这些资源将不会被回收，造成内存泄漏 集合中对象没有清理造成的内存泄漏,在实际开发过程中难免会有把对象添加到集合容器（比如 ArrayList）中的需求，如果在一个对象使用结束之后未将该对象从该容器中移除掉，就会造成该对象不能被正确回收，从而造成内存泄漏，解决办法当然就是在使用完之后将该对象从容器中移除。 webview引起的内存泄漏主要是因为org.chromium.android_webview.AwContents 类中注册了component callbacks，但是未正常反注册而导致的。让onDetachedFromWindow先走，在主动调用destroy()之前，把webview从它的parent上面移除掉(Basewebfragment onDestroy()) 内存优化 降低运行时内存: 降低运行时内存可以分为两部分: 减小apk体积:去除无用的代码和资源,尽量复用资源,对图片资源进行压缩 Bitmap优化: 统一的图片加载器:图片加载器默认会对图片进行缓存,按view的实际大小进行加载.inSampleSize进行缩放比例,选择合适的bitmap格式(ARGB_8888/RGB_565/ARGB——4444/ALPHA_8) 代码优化:考虑使用ArrayMap/SpareseArray 而不是传统的HashMap等数据结构,Android系统未移动系统设计的容器ArrayMap更加高效,占用内存更少,因为HashMap需要一个额外的实例对象来记录Mapping的操作.而SparesArray高效的避免了key和value的自动装箱,而且避免了装箱后的拆箱 在onDraw这种频繁调用的方法要避免对象的创建操作,它会迅速增加内存的使用,引起频繁gc,甚至内存抖动. SoftReference(软引用)、WeakReference(弱引用)、PhantomReference(虚引用): 123SoftReference：如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。WeakReference：与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。PhantomReference：虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之 关联的引用队列中。 考虑第三方库的大小，如果会和现有的代码或其他库的代码重复，考虑不要真个引入而是把库的代码精简之后再引入。 流畅优化 界面绘制:主要原因是绘制的层级深,页面复杂,刷新不合理 布局服用,使用标签重用layout;提高显示速度,使用延迟view加载;减少层级,使用标签替换父级布局;wrap_content,会增加measure计算成本;删除空间中无用属性. 数据处理:导致这种卡顿场景的原因在于数据处理量太大,一般分三种情况:一是数据处理在UI线程,二是数据处理占用的cpu高,导致主线程拿不到时间片,三是内存增加导致GC频繁,从而引起卡顿 参考Android内存泄漏的检测与分析以及解决方案小结谈一谈Android内存优化那些事（二）Android常用的内存优化方法","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"面试","slug":"面试","permalink":"http://yoursite.com/tags/面试/"}]},{"title":"AsyncTask源码分析","slug":"AsyncTask","date":"2019-07-18T16:00:00.000Z","updated":"2019-07-19T05:46:31.876Z","comments":true,"path":"2019/07/19/AsyncTask/","link":"","permalink":"http://yoursite.com/2019/07/19/AsyncTask/","excerpt":"先看一下用法 AsyncTask&lt;Void, Void, Void&gt; asyncTask = new AsyncTask&lt;Void, Void, Void&gt;() { @Override protected Void doInBackground(Void... voids) { return null; } }; asyncTask.execute();源码中这是一个抽象类,必须自己去实现,才能使用","text":"先看一下用法 AsyncTask&lt;Void, Void, Void&gt; asyncTask = new AsyncTask&lt;Void, Void, Void&gt;() { @Override protected Void doInBackground(Void... voids) { return null; } }; asyncTask.execute();源码中这是一个抽象类,必须自己去实现,才能使用 1public abstract class AsyncTask&lt;Params, Progress, Result&gt; 有三个参数,第一个是你要传什么东西异步使用,一般可能是网址,不需要传可以填void,第二个参数为执行进度,不需要也可以填void,第三个是返回数据,也可以填void. 用asyncTask.execute()执行AsyncTask,括号中填的跟第一个参数对应. excute()方法调用了这个方法,还是在主线程中 @MainThread public final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) { return executeOnExecutor(sDefaultExecutor, params); }之后调用 @MainThread public final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec, Params... params) { if (mStatus != Status.PENDING) { switch (mStatus) { case RUNNING: throw new IllegalStateException(&quot;Cannot execute task:&quot; + &quot; the task is already running.&quot;); case FINISHED: throw new IllegalStateException(&quot;Cannot execute task:&quot; + &quot; the task has already been executed &quot; + &quot;(a task can be executed only once)&quot;); } } mStatus = Status.RUNNING; onPreExecute(); mWorker.mParams = params; exec.execute(mFuture); return this; }这个方法中判断了mStatus的状态,里面有两个异常抛出,可以看出一个任务只能执行一次. 而mStatus在初始化时置为了Status.PENDING,所以不会进入if (mStatus != Status.PENDING),会改变mStatus状态:mStatus = Status.RUNNING; private volatile Status mStatus = Status.PENDING;接下来调用onPreExecute(),点进去看一下这个方法. @MainThread protected void onPreExecute() { }这方法是空实现,注解表示此时仍在主线程中,之后调用 12exec.execute(mFuture);void execute(Runnable command); exec是之前的sDefaultExecutor 12345678private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR;public static final Executor SERIAL_EXECUTOR = new SerialExecutor();private static class SerialExecutor implements Executor &#123; final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;(); Runnable mActive; public synchronized void execute(final Runnable r) { mTasks.offer(new Runnable() { public void run() { try { r.run(); } finally { scheduleNext(); } } }); if (mActive == null) { scheduleNext(); } } protected synchronized void scheduleNext() { if ((mActive = mTasks.poll()) != null) { THREAD_POOL_EXECUTOR.execute(mActive); } } }scheduleNext()在这个方法中,由线程池来执行任务 12345678910protected synchronized void scheduleNext() &#123; if ((mActive = mTasks.poll()) != null) &#123; THREAD_POOL_EXECUTOR.execute(mActive); &#125; &#125; public E poll() &#123; return pollFirst(); &#125; 也就是会调出第一个任务来执行 execute方法 需要一个Runnable,最终调用Runnable的run方法,也就是mFuture的run方法 12345678910111213141516171819202122232425262728293031public void run() &#123; if (state != NEW || !U.compareAndSwapObject(this, RUNNER, null, Thread.currentThread())) return; try &#123; Callable&lt;V&gt; c = callable; if (c != null &amp;&amp; state == NEW) &#123; V result; boolean ran; try &#123; result = c.call(); ran = true; &#125; catch (Throwable ex) &#123; result = null; ran = false; setException(ex); &#125; if (ran) set(result); &#125; &#125; finally &#123; // runner must be non-null until state is settled to // prevent concurrent calls to run() runner = null; // state must be re-read after nulling runner to prevent // leaked interrupts int s = state; if (s &gt;= INTERRUPTING) handlePossibleCancellationInterrupt(s); &#125; &#125; 并调用了c.call()方法,而mFuture初始化时传入了一个callable,也就是调用的这个callable的call方法 123456public FutureTask(Callable&lt;V&gt; callable) &#123; if (callable == null) throw new NullPointerException(); this.callable = callable; this.state = NEW; // ensure visibility of callable &#125; mFuture在初始化时传进去一个mWorker,也就是一个Callable 123456789101112131415161718mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123; public Result call() throws Exception &#123; mTaskInvoked.set(true); Result result = null; try &#123; Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); //noinspection unchecked result = doInBackground(mParams); Binder.flushPendingCommands(); &#125; catch (Throwable tr) &#123; mCancelled.set(true); throw tr; &#125; finally &#123; postResult(result); &#125; return result; &#125; &#125;; 在这里执行了doInBackground(mParams),且是异步执行,在finally中调用了 postResult(result),publishProgress需要手动调用才会执行. postResult(result)方法是在异步调用,但方法里的实现使用Handler发送消息到主线程 private Result postResult(Result result) { @SuppressWarnings(&quot;unchecked&quot;) Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT, new AsyncTaskResult&lt;Result&gt;(this, result)); message.sendToTarget(); return result; }1234private static class InternalHandler extends Handler &#123; public InternalHandler(Looper looper) &#123; super(looper); &#125; @SuppressWarnings({&quot;unchecked&quot;, &quot;RawUseOfParameterizedType&quot;}) @Override public void handleMessage(Message msg) { AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj; switch (msg.what) { case MESSAGE_POST_RESULT: // There is only one result result.mTask.finish(result.mData[0]); break; case MESSAGE_POST_PROGRESS: result.mTask.onProgressUpdate(result.mData); break; } } }最终在主线程中回调了publishProgress和onPostExecute(result) 1234567@WorkerThread protected final void publishProgress(Progress... values) &#123; if (!isCancelled()) &#123; getHandler().obtainMessage(MESSAGE_POST_PROGRESS, new AsyncTaskResult&lt;Progress&gt;(this, values)).sendToTarget(); &#125; &#125; private void finish(Result result) { if (isCancelled()) { onCancelled(result); } else { onPostExecute(result); } mStatus = Status.FINISHED; }","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"源码","slug":"源码","permalink":"http://yoursite.com/tags/源码/"}]},{"title":"关于面试(二)","slug":"关于面试(二)","date":"2019-07-18T16:00:00.000Z","updated":"2019-07-19T06:18:13.835Z","comments":true,"path":"2019/07/19/关于面试(二)/","link":"","permalink":"http://yoursite.com/2019/07/19/关于面试(二)/","excerpt":"view的绘制流程Android的UI管理系统层级关系 View的绘制过程是从ViewRoot的performTraversals方法开始的，在其内部依次调用View的performMeasure,performLayout,performDraw三个方法。这三个方法分别完成顶级View的measure,layout,draw过程。其中，performMeasure中会调用measure方法，而在measure方法中又会调用onMeausre()方法，然后在onMeaure方法中会对所有的子元素进行measure过程，这时measure流程就从父容器传递到了子元素中，子元素会继续重复父容器的measure过程，如此反复即完成了整个View树结构的遍历，最终 完成View的测量过程。","text":"view的绘制流程Android的UI管理系统层级关系 View的绘制过程是从ViewRoot的performTraversals方法开始的，在其内部依次调用View的performMeasure,performLayout,performDraw三个方法。这三个方法分别完成顶级View的measure,layout,draw过程。其中，performMeasure中会调用measure方法，而在measure方法中又会调用onMeausre()方法，然后在onMeaure方法中会对所有的子元素进行measure过程，这时measure流程就从父容器传递到了子元素中，子元素会继续重复父容器的measure过程，如此反复即完成了整个View树结构的遍历，最终 完成View的测量过程。 同理，performLayout和performDraw方法的传递流程和performMeasure类似，但不同的是，performDraw的传递是在draw方法中通过dispatchDraw方法来下发的，不过本质上原理还是一样的。下面给出一张流程图方便大家更好的理解：只看一下主要几个方法: performMeasure 12345678private void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) &#123; Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;measure&quot;); try &#123; mView.measure(childWidthMeasureSpec, childHeightMeasureSpec); &#125; finally &#123; Trace.traceEnd(Trace.TRACE_TAG_VIEW); &#125; &#125; 1234public final void measure(int widthMeasureSpec, int heightMeasureSpec) &#123; // 调用onMeasure() onMeasure(widthMeasureSpec, heightMeasureSpec); &#125; 123456789@Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; if (mOrientation == VERTICAL) &#123; // 我们以垂直为例 measureVertical(widthMeasureSpec, heightMeasureSpec); &#125; else &#123; measureHorizontal(widthMeasureSpec, heightMeasureSpec); &#125; &#125; 12345678910111213141516171819202122232425void measureVertical(int widthMeasureSpec, int heightMeasureSpec) &#123; // See how tall everyone is. Also remember max width. for (int i = 0; i &lt; count; ++i) &#123; final View child = getVirtualChildAt(i); // 测量子孩子 measureChildBeforeLayout(child, i, widthMeasureSpec, 0, heightMeasureSpec, usedHeight); final int childHeight = child.getMeasuredHeight(); final int totalLength = mTotalLength; // 高度是子View的高度不断的叠加 mTotalLength = Math.max(totalLength, totalLength + childHeight + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child)); &#125; int heightSize = mTotalLength; // Check against our minimum height heightSize = Math.max(heightSize, getSuggestedMinimumHeight()); // Reconcile our calculated size with the heightMeasureSpec int heightSizeAndState = resolveSizeAndState(heightSize, heightMeasureSpec, 0); // 设置宽高 setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState), heightSizeAndState); &#125; ViewGroup在调用onMeasure()方法的时候,会不断的循环测量子view. 123456void measureChildBeforeLayout(View child, int childIndex, int widthMeasureSpec, int totalWidth, int heightMeasureSpec, int totalHeight) &#123; measureChildWithMargins(child, widthMeasureSpec, totalWidth, heightMeasureSpec, totalHeight); &#125; 1234567891011121314protected void measureChildWithMargins(View child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed) &#123; final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams(); // getChildMeasureSpec 这个方法非常关键 final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin + widthUsed, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin + heightUsed, lp.height); child.measure(childWidthMeasureSpec, childHeightMeasureSpec); &#125; 三种测量方式: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public static int getChildMeasureSpec(int spec, int padding, int childDimension) &#123; //获取当前Parent View的Mode和Size int specMode = MeasureSpec.getMode(spec); int specSize = MeasureSpec.getSize(spec); //获取Parent size与padding差值（也就是Parent剩余大小），若差值小于0直接返回0 int size = Math.max(0, specSize - padding); //定义返回值存储变量 int resultSize = 0; int resultMode = 0; //依据当前Parent的Mode进行switch分支逻辑 switch (specMode) &#123; // Parent has imposed an exact size on us case MeasureSpec.EXACTLY: if (childDimension &gt;= 0) &#123; //如果child的layout_w和h属性在xml或者java中给予具体大于等于0的数值 //设置child的size为真实layout_w和h属性值，mode为EXACTLY resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // Child wants to be our size. So be it. //如果child的layout_wOrh属性在xml或者java中给予MATCH_PARENT //设置child的size为size，mode为EXACTLY resultSize = size; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // Child wants to determine its own size. It can&apos;t be // bigger than us. //如果child的layout_wOrh属性在xml或者java中给予WRAP_CONTENT //设置child的size为size，mode为AT_MOST resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; break; // Parent has imposed a maximum size on us case MeasureSpec.AT_MOST: if (childDimension &gt;= 0) &#123; // ...... &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; // Child wants to be our size, but our size is not fixed. // Constrain child to not be bigger than us. // 如果父 View 是 AT_MOST 就算子 View 是 MATCH_PARENT， // 其实子View获得的测量模式还是AT_MOST resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; // Child wants to determine its own size. It can&apos;t be // bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; break; // ...... &#125; //noinspection ResourceType return MeasureSpec.makeMeasureSpec(resultSize, resultMode); &#125; View的绘制流程第一步是onMeasure()，该方法用来测量和指定布局到底占多大的宽高，因为控件的宽高是由父布局和本身来决定的，所以测量是不断的往内走，而最终确定宽高是由内不断的往外走，是递归的方式。 performLayout 12345678910private void performLayout(WindowManager.LayoutParams lp, int desiredWindowWidth, int desiredWindowHeight) &#123; final View host = mView; // 调用layout()方法 host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight()); &#125; public void layout(int l, int t, int r, int b) &#123; onLayout(changed, l, t, r, b); &#125; 123456789@Override protected void onLayout(boolean changed, int l, int t, int r, int b) &#123; if (mOrientation == VERTICAL) &#123; // 我们以垂直为例 layoutVertical(l, t, r, b); &#125; else &#123; layoutHorizontal(l, t, r, b); &#125; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687void layoutVertical(int left, int top, int right, int bottom) &#123; final int paddingLeft = mPaddingLeft; int childTop; int childLeft; // Where right end of child should go //计算父窗口推荐的子View宽度 final int width = right - left; //计算父窗口推荐的子View右侧位置 int childRight = width - mPaddingRight; // Space available for child //child可使用空间大小 int childSpace = width - paddingLeft - mPaddingRight; //通过ViewGroup的getChildCount方法获取ViewGroup的子View个数 final int count = getVirtualChildCount(); //获取Gravity属性设置 final int majorGravity = mGravity &amp; Gravity.VERTICAL_GRAVITY_MASK; final int minorGravity = mGravity &amp; Gravity.RELATIVE_HORIZONTAL_GRAVITY_MASK; //依据majorGravity计算childTop的位置值 switch (majorGravity) &#123; case Gravity.BOTTOM: // mTotalLength contains the padding already childTop = mPaddingTop + bottom - top - mTotalLength; break; // mTotalLength contains the padding already case Gravity.CENTER_VERTICAL: childTop = mPaddingTop + (bottom - top - mTotalLength) / 2; break; case Gravity.TOP: default: childTop = mPaddingTop; break; &#125; //重点！！！开始遍历 for (int i = 0; i &lt; count; i++) &#123; final View child = getVirtualChildAt(i); if (child == null) &#123; childTop += measureNullChild(i); &#125; else if (child.getVisibility() != GONE) &#123; //LinearLayout中其子视图显示的宽和高由measure过程来决定的，因此measure过程的意义就是为layout过程提供视图显示范围的参考值 final int childWidth = child.getMeasuredWidth(); final int childHeight = child.getMeasuredHeight(); //获取子View的LayoutParams final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams(); int gravity = lp.gravity; if (gravity &lt; 0) &#123; gravity = minorGravity; &#125; final int layoutDirection = getLayoutDirection(); final int absoluteGravity = Gravity.getAbsoluteGravity(gravity, layoutDirection); //依据不同的absoluteGravity计算childLeft位置 switch (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) &#123; case Gravity.CENTER_HORIZONTAL: childLeft = paddingLeft + ((childSpace - childWidth) / 2) + lp.leftMargin - lp.rightMargin; break; case Gravity.RIGHT: childLeft = childRight - childWidth - lp.rightMargin; break; case Gravity.LEFT: default: childLeft = paddingLeft + lp.leftMargin; break; &#125; if (hasDividerBeforeChildAt(i)) &#123; childTop += mDividerHeight; &#125; childTop += lp.topMargin; //通过垂直排列计算调运child的layout设置child的位置 setChildFrame(child, childLeft, childTop + getLocationOffset(child), childWidth, childHeight); childTop += childHeight + lp.bottomMargin + getNextLocationOffset(child); i += getChildrenSkipCount(child, i); &#125; &#125; &#125; 从上面分析可以看出layout也是从顶层父View向子View的递归调用view.layout方法的过程，即父View根据第一步performMeasure，来获取子View所的布局大小和布局参数，将子View放在合适的位置上，不过这个方法没有再往外走，只是不断的往里面走。 performDraw 1234567891011121314151617181920212223242526272829303132private void performDraw() &#123; try &#123; draw(fullRedrawNeeded); &#125; finally &#123; mIsDrawing = false; Trace.traceEnd(Trace.TRACE_TAG_VIEW); &#125; &#125; private void draw(boolean fullRedrawNeeded) &#123; Surface surface = mSurface; if (!surface.isValid()) &#123; return; &#125; if (!drawSoftware(surface, mAttachInfo, xOffset, yOffset, scalingRequired, dirty)) &#123; return; &#125; &#125; private boolean drawSoftware(Surface surface, AttachInfo attachInfo, int xoff, int yoff, boolean scalingRequired, Rect dirty) &#123; // Draw with software renderer. final Canvas canvas; final int left = dirty.left; final int top = dirty.top; final int right = dirty.right; final int bottom = dirty.bottom; canvas = mSurface.lockCanvas(dirty); // ... ... mView.draw(canvas); &#125; 事件分发 事件类型(down,up,move,cancel),从手指借出屏幕到手指离开屏幕为一组事件 事件分发的本质就是将点击事件传递到某个具体的view&amp;处理的整个过程. 事件在Activity,ViewGroup,View中传递 事件分发由哪些方法协作完成 activity的事件分发: ViewGroup的事件分发: View的事件分发: 总结 测试从Activity到ViewGroup到View. Activity类中添加一下代码 12345678910111213141516@Override public boolean onTouchEvent(MotionEvent event) &#123; Log.e(&quot;gao&quot;, &quot;onTouchEvent: &quot;+this.getClass().getName()); return super.onTouchEvent(event); &#125; @Override public void onClick(View v) &#123; Log.e(&quot;gao&quot;, &quot;onClick: &quot;+this.getClass().getName()); &#125; @Override public boolean dispatchTouchEvent(MotionEvent ev) &#123; Log.e(&quot;gao&quot;, &quot;dispatchTouchEvent: &quot;+this.getClass().getName()); return super.dispatchTouchEvent(ev); &#125; ViewGroup中添加以下代码: 1234567891011121314151617@Override public boolean dispatchTouchEvent(MotionEvent ev) &#123; Log.e(&quot;gao&quot;, &quot;dispatchTouchEvent: &quot;+this.getClass().getName()); return super.dispatchTouchEvent(ev); &#125; @Override public boolean onInterceptTouchEvent(MotionEvent ev) &#123; Log.e(&quot;gao&quot;, &quot;onInterceptTouchEvent: &quot;+this.getClass().getName()); return super.onInterceptTouchEvent(ev); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; Log.e(&quot;gao&quot;, &quot;onTouchEvent: &quot;+this.getClass().getName()); return super.onTouchEvent(event); &#125; View中添加以下代码: 1234567891011@Override public boolean onTouchEvent(MotionEvent event) &#123; Log.e(&quot;gao&quot;, &quot;onTouchEvent: &quot;+this.getClass().getName()); return super.onTouchEvent(event); &#125; @Override public boolean dispatchTouchEvent(MotionEvent event) &#123; Log.e(&quot;gao&quot;, &quot;dispatchTouchEvent: &quot;+this.getClass().getName()); return super.dispatchTouchEvent(event); &#125; 默认情况下调用顺序: 12345678904-17 08:03:09.766 2887-2887/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity04-17 08:03:09.767 2887-2887/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela04-17 08:03:09.767 2887-2887/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela04-17 08:03:09.767 2887-2887/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn04-17 08:03:09.767 2887-2887/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn04-17 08:03:09.786 2887-2887/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyRela04-17 08:03:09.786 2887-2887/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity04-17 08:03:09.889 2887-2887/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity04-17 08:03:09.889 2887-2887/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity view中touchEvent改为true 1234567891004-17 08:06:14.757 2992-2992/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity04-17 08:06:14.757 2992-2992/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela04-17 08:06:14.757 2992-2992/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela04-17 08:06:14.757 2992-2992/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn04-17 08:06:14.757 2992-2992/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn04-17 08:06:14.757 2992-2992/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity04-17 08:06:14.757 2992-2992/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela04-17 08:06:14.757 2992-2992/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela04-17 08:06:14.757 2992-2992/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn04-17 08:06:14.757 2992-2992/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn 事件传到View后不再往外传,因为已经被消费了 方法都调用了两遍是因为接收了down事件之后,up事件也传过来接收了 view中touchEvent改为false 12345678904-17 08:23:47.369 3622-3622/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity04-17 08:23:47.370 3622-3622/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela04-17 08:23:47.370 3622-3622/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela04-17 08:23:47.370 3622-3622/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn04-17 08:23:47.370 3622-3622/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn04-17 08:23:47.370 3622-3622/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyRela04-17 08:23:47.370 3622-3622/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity04-17 08:23:47.505 3622-3622/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity04-17 08:23:47.505 3622-3622/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity View的dispatchTouchEvent改为true 123404-17 08:26:52.930 3721-3721/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity04-17 08:26:52.930 3721-3721/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela04-17 08:26:52.930 3721-3721/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela04-17 08:26:52.930 3721-3721/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn 不再分发,不消费,会接收后续事件 View的dispatchTouchEvent改为false 1234567804-17 08:29:02.066 3822-3822/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity04-17 08:29:02.067 3822-3822/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela04-17 08:29:02.067 3822-3822/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela04-17 08:29:02.067 3822-3822/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn04-17 08:29:02.067 3822-3822/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyRela04-17 08:29:02.067 3822-3822/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity04-17 08:29:02.176 3822-3822/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity04-17 08:29:02.176 3822-3822/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity 不再分发.会传给外层布局的onTouchEvent进行消费,如果都不进行消费,则后续事件不再向内分发. 只有View的dispatchTouchEvent为默认值时才会调View的onTouchEvent方法. ViewGroup中 onTouchEvent返回true 12345678904-17 08:42:18.120 4533-4533/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity04-17 08:42:18.121 4533-4533/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela04-17 08:42:18.121 4533-4533/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela04-17 08:42:18.122 4533-4533/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn04-17 08:42:18.122 4533-4533/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn04-17 08:42:18.122 4533-4533/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyRela04-17 08:42:35.925 4533-4533/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity04-17 08:42:35.925 4533-4533/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela04-17 08:42:35.925 4533-4533/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyRela 消费之后会仍会分发给子类,如果子类不消费,后续事件不再分发给子类. 于此同时把View的onTouchEvent方法改为true 1234567891004-17 08:44:28.544 4635-4635/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity04-17 08:44:28.545 4635-4635/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela04-17 08:44:28.545 4635-4635/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela04-17 08:44:28.545 4635-4635/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn04-17 08:44:28.545 4635-4635/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn04-17 08:44:34.966 4635-4635/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity04-17 08:44:34.966 4635-4635/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela04-17 08:44:34.966 4635-4635/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela04-17 08:44:34.966 4635-4635/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn04-17 08:44:34.966 4635-4635/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn 对ViewGroup的事件消费,且后续事件会传递到View中. onTouchEvent返回false 12345678904-17 08:46:36.068 4735-4735/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity04-17 08:46:36.068 4735-4735/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela04-17 08:46:36.068 4735-4735/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela04-17 08:46:36.068 4735-4735/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn04-17 08:46:36.068 4735-4735/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn04-17 08:46:36.068 4735-4735/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyRela04-17 08:46:36.068 4735-4735/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity04-17 08:47:04.229 4735-4735/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity04-17 08:47:04.229 4735-4735/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity 不进行消费,当次事件会继续分发,如果子View不进行消费则后续事件不再分发进ViewGroup,如果子View进行消费,则后续事件仍会分发,只是不再经过ViewGroup的OntouchEvent() 1234567891004-17 08:50:15.560 5023-5023/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity04-17 08:50:15.560 5023-5023/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela04-17 08:50:15.560 5023-5023/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela04-17 08:50:15.560 5023-5023/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn04-17 08:50:15.560 5023-5023/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn04-17 08:50:19.491 5023-5023/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity04-17 08:50:19.491 5023-5023/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela04-17 08:50:19.491 5023-5023/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela04-17 08:50:19.491 5023-5023/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn04-17 08:50:19.491 5023-5023/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn onInterceptTouchEvent返回true 123456704-17 08:53:53.191 5127-5127/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity04-17 08:53:53.193 5127-5127/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela04-17 08:53:53.193 5127-5127/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela04-17 08:53:53.193 5127-5127/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyRela04-17 08:53:53.193 5127-5127/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity04-17 08:54:08.389 5127-5127/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity04-17 08:54:08.389 5127-5127/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity 拦截后事件不会据需分发,会调用ViewGroup的OntouchVent,如果不进行消费,后续事件不会分发进来. 与此同时,把onTOuchEvent的返回值改为true 123456704-17 08:56:00.350 5228-5228/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity04-17 08:56:00.350 5228-5228/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela04-17 08:56:00.350 5228-5228/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela04-17 08:56:00.351 5228-5228/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyRela04-17 08:56:02.535 5228-5228/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity04-17 08:56:02.535 5228-5228/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela04-17 08:56:02.535 5228-5228/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyRela 拦截之后进行消费,后续事件仍会继续分发,但不再调用拦截方法 把dispatchTouchEvent返回true 123404-17 09:00:31.695 5428-5428/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity04-17 09:00:31.695 5428-5428/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela04-17 09:00:31.813 5428-5428/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity04-17 09:00:31.814 5428-5428/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela 往外分发,仍接收后续事件 改为false 1234504-17 09:02:19.810 5529-5529/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity04-17 09:02:19.810 5529-5529/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela04-17 09:02:19.810 5529-5529/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity04-17 09:02:19.928 5529-5529/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity04-17 09:02:19.928 5529-5529/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity 向外分发,不再接收后续事件,会调用Activity的onTouchEvent() Activity中 dispatchTouchEvent返回true或false 1204-17 09:08:04.216 5728-5728/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity04-17 09:08:04.333 5728-5728/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity onTouchEvent()改为true 12345678904-17 09:09:23.950 5931-5931/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity04-17 09:09:23.950 5931-5931/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela04-17 09:09:23.951 5931-5931/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela04-17 09:09:23.951 5931-5931/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn04-17 09:09:23.951 5931-5931/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn04-17 09:09:23.951 5931-5931/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyRela04-17 09:09:23.951 5931-5931/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity04-17 09:09:24.094 5931-5931/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity04-17 09:09:24.094 5931-5931/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity 当次事件会继续分发,如果没有子控件消费,后续事件不再分发.直接调用onTouchEvent, 于此同时把View中的onTouchEvent方法返回true 1234567891004-17 09:15:08.467 6031-6031/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity04-17 09:15:08.467 6031-6031/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela04-17 09:15:08.467 6031-6031/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela04-17 09:15:08.467 6031-6031/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn04-17 09:15:08.467 6031-6031/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn04-17 09:15:11.154 6031-6031/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity04-17 09:15:11.154 6031-6031/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela04-17 09:15:11.154 6031-6031/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela04-17 09:15:11.154 6031-6031/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn04-17 09:15:11.154 6031-6031/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn View会先于Activity消费事件,且后续事件会继续分发到View 把Activity的onTouchEvent()置为false,且子类不消费事件,则当次事件继续分发,后续事件不再分发,直接调用Activity的onTouchEvent方法. 参考源码解析 - View的绘制流程Android 自定义View——View的绘制流程Android事件分发机制详解：史上最全面、最易懂","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"面试","slug":"面试","permalink":"http://yoursite.com/tags/面试/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-07-11T03:13:37.890Z","updated":"2019-07-19T05:46:55.830Z","comments":true,"path":"2019/07/11/hello-world/","link":"","permalink":"http://yoursite.com/2019/07/11/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}