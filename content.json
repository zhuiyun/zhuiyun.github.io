{"meta":{"title":"CoolYun","subtitle":null,"description":null,"author":"CoolYun","url":"http://yoursite.com","root":"/"},"pages":[{"title":"所有标签","date":"2019-07-11T11:29:43.731Z","updated":"2019-07-11T11:29:43.713Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2019-07-11T11:28:45.457Z","updated":"2019-07-11T11:28:45.440Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2019-07-19T02:31:42.225Z","updated":"2019-07-11T11:25:21.629Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""}],"posts":[{"title":"关于面试(一)","slug":"关于面试(一)","date":"2019-07-18T16:00:00.000Z","updated":"2019-07-19T03:33:35.044Z","comments":true,"path":"2019/07/19/关于面试(一)/","link":"","permalink":"http://yoursite.com/2019/07/19/关于面试(一)/","excerpt":"","text":"内存泄漏 内部类隐性的持有外部类的引用导致内存泄漏:常见的如使用handler时,直接new创建对象,当页面关闭时,如果handler还在运行时会持有activity的引用,导致activity得不到释放,从而引起内存泄漏。 解决方法:使用静态内部类,然后用弱引用持有外部类的引用 静态变量引起的内存泄漏:静态变量的生命周期和应用的生命周期一样长,如果用静态变量引用了某个activity的实例会导致activity得不到释放, 解决方法:将activity的引用改为application的引用 资源对象未关闭:对于使用了BraodcastReceiver，ContentObserver，File，Cursor，Stream，Bitmap等资源的代码，应该在Activity销毁时及时关闭或者注销，否则这些资源将不会被回收，造成内存泄漏 集合中对象没有清理造成的内存泄漏,在实际开发过程中难免会有把对象添加到集合容器（比如 ArrayList）中的需求，如果在一个对象使用结束之后未将该对象从该容器中移除掉，就会造成该对象不能被正确回收，从而造成内存泄漏，解决办法当然就是在使用完之后将该对象从容器中移除。 webview引起的内存泄漏主要是因为org.chromium.android_webview.AwContents 类中注册了component callbacks，但是未正常反注册而导致的。让onDetachedFromWindow先走，在主动调用destroy()之前，把webview从它的parent上面移除掉(Basewebfragment onDestroy()) 内存优化 降低运行时内存: 降低运行时内存可以分为两部分: 减小apk体积:去除无用的代码和资源,尽量复用资源,对图片资源进行压缩 Bitmap优化: 统一的图片加载器:图片加载器默认会对图片进行缓存,按view的实际大小进行加载.inSampleSize进行缩放比例,选择合适的bitmap格式(ARGB_8888/RGB_565/ARGB——4444/ALPHA_8) 代码优化:考虑使用ArrayMap/SpareseArray 而不是传统的HashMap等数据结构,Android系统未移动系统设计的容器ArrayMap更加高效,占用内存更少,因为HashMap需要一个额外的实例对象来记录Mapping的操作.而SparesArray高效的避免了key和value的自动装箱,而且避免了装箱后的拆箱 在onDraw这种频繁调用的方法要避免对象的创建操作,它会迅速增加内存的使用,引起频繁gc,甚至内存抖动. SoftReference(软引用)、WeakReference(弱引用)、PhantomReference(虚引用): 123SoftReference：如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。WeakReference：与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。PhantomReference：虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之 关联的引用队列中。 考虑第三方库的大小，如果会和现有的代码或其他库的代码重复，考虑不要真个引入而是把库的代码精简之后再引入。 流畅优化 界面绘制:主要原因是绘制的层级深,页面复杂,刷新不合理 布局服用,使用标签重用layout;提高显示速度,使用延迟view加载;减少层级,使用标签替换父级布局;wrap_content,会增加measure计算成本;删除空间中无用属性. 数据处理:导致这种卡顿场景的原因在于数据处理量太大,一般分三种情况:一是数据处理在UI线程,二是数据处理占用的cpu高,导致主线程拿不到时间片,三是内存增加导致GC频繁,从而引起卡顿 参考Android内存泄漏的检测与分析以及解决方案小结谈一谈Android内存优化那些事（二）Android常用的内存优化方法","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"面试","slug":"面试","permalink":"http://yoursite.com/tags/面试/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-07-11T03:13:37.890Z","updated":"2019-07-11T03:13:37.890Z","comments":true,"path":"2019/07/11/hello-world/","link":"","permalink":"http://yoursite.com/2019/07/11/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}