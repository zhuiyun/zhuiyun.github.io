<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>解决AndroidStudio的命令行乱码</title>
      <link href="/2019/07/31/AndroidStudio%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B9%B1%E7%A0%81/"/>
      <url>/2019/07/31/AndroidStudio%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B9%B1%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>#解决AndroidStudio命令行乱码</p><h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>用的macbook,下载了iTerm2后,根据网上博客配置了一些属性,之后打开Androidstudio时,发现命令行乱码,鼓捣了一阵终于搞定<br> <a id="more"></a></p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>这个情况主要是修改了命令行的字体,但Androidstudio中有默认字体,两者不是同一个造成的,只需修改其中之一即可,我改的是Androidstudio.修改位置如下图:<br><img src="https://i.loli.net/2019/07/31/5d4168e4e131675700.png" alt><br>需要和iTerm2中字体一致<br><img src="https://i.loli.net/2019/07/31/5d41688ed76d781045.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 问题解决 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AsyncTask源码分析</title>
      <link href="/2019/07/19/AsyncTask/"/>
      <url>/2019/07/19/AsyncTask/</url>
      
        <content type="html"><![CDATA[<p>先看一下用法</p><pre><code>AsyncTask&lt;Void, Void, Void&gt; asyncTask = new AsyncTask&lt;Void, Void, Void&gt;() {    @Override    protected Void doInBackground(Void... voids) {        return null;    }};asyncTask.execute();</code></pre><p>源码中这是一个抽象类,必须自己去实现,才能使用</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AsyncTask&lt;Params, Progress, Result&gt;</span><br></pre></td></tr></table></figure><p>有三个参数,第一个是你要传什么东西异步使用,一般可能是网址,不需要传可以填void,第二个参数为执行进度,不需要也可以填void,第三个是返回数据,也可以填void.</p><p>用asyncTask.execute()执行AsyncTask,括号中填的跟第一个参数对应. excute()方法调用了这个方法,还是在主线程中</p><pre><code>@MainThreadpublic final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) {    return executeOnExecutor(sDefaultExecutor, params);}</code></pre><p>之后调用</p><pre><code>@MainThreadpublic final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec,        Params... params) {    if (mStatus != Status.PENDING) {        switch (mStatus) {            case RUNNING:                throw new IllegalStateException(&quot;Cannot execute task:&quot;                        + &quot; the task is already running.&quot;);            case FINISHED:                throw new IllegalStateException(&quot;Cannot execute task:&quot;                        + &quot; the task has already been executed &quot;                        + &quot;(a task can be executed only once)&quot;);        }    }    mStatus = Status.RUNNING;    onPreExecute();    mWorker.mParams = params;    exec.execute(mFuture);    return this;}</code></pre><p>这个方法中判断了mStatus的状态,里面有两个异常抛出,可以看出一个任务只能执行一次. 而mStatus在初始化时置为了Status.PENDING,所以不会进入if (mStatus != Status.PENDING),会改变mStatus状态:mStatus = Status.RUNNING;</p><p>private volatile Status mStatus = Status.PENDING;<br>接下来调用onPreExecute(),点进去看一下这个方法.</p><pre><code>@MainThreadprotected void onPreExecute() {}</code></pre><p>这方法是空实现,注解表示此时仍在主线程中,之后调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exec.execute(mFuture);</span><br><span class="line">void execute(Runnable command);</span><br></pre></td></tr></table></figure><p>exec是之前的sDefaultExecutor</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR;</span><br><span class="line"></span><br><span class="line">public static final Executor SERIAL_EXECUTOR = new SerialExecutor();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private static class SerialExecutor implements Executor &#123;</span><br><span class="line">        final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;();</span><br><span class="line">        Runnable mActive;</span><br></pre></td></tr></table></figure><pre><code>    public synchronized void execute(final Runnable r) {        mTasks.offer(new Runnable() {            public void run() {                try {                    r.run();                } finally {                    scheduleNext();                }            }        });        if (mActive == null) {            scheduleNext();        }    }    protected synchronized void scheduleNext() {        if ((mActive = mTasks.poll()) != null) {            THREAD_POOL_EXECUTOR.execute(mActive);        }    }}</code></pre><p>scheduleNext()在这个方法中,由线程池来执行任务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">protected synchronized void scheduleNext() &#123;</span><br><span class="line">            if ((mActive = mTasks.poll()) != null) &#123;</span><br><span class="line">                THREAD_POOL_EXECUTOR.execute(mActive);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">public E poll() &#123;</span><br><span class="line">        return pollFirst();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p> 也就是会调出第一个任务来执行</p><p>execute方法 需要一个Runnable,最终调用Runnable的run方法,也就是mFuture的run方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public void run() &#123;</span><br><span class="line">        if (state != NEW ||</span><br><span class="line">            !U.compareAndSwapObject(this, RUNNER, null, Thread.currentThread()))</span><br><span class="line">            return;</span><br><span class="line">        try &#123;</span><br><span class="line">            Callable&lt;V&gt; c = callable;</span><br><span class="line">            if (c != null &amp;&amp; state == NEW) &#123;</span><br><span class="line">                V result;</span><br><span class="line">                boolean ran;</span><br><span class="line">                try &#123;</span><br><span class="line">                    result = c.call();</span><br><span class="line">                    ran = true;</span><br><span class="line">                &#125; catch (Throwable ex) &#123;</span><br><span class="line">                    result = null;</span><br><span class="line">                    ran = false;</span><br><span class="line">                    setException(ex);</span><br><span class="line">                &#125;</span><br><span class="line">                if (ran)</span><br><span class="line">                    set(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            // runner must be non-null until state is settled to</span><br><span class="line">            // prevent concurrent calls to run()</span><br><span class="line">            runner = null;</span><br><span class="line">            // state must be re-read after nulling runner to prevent</span><br><span class="line">            // leaked interrupts</span><br><span class="line">            int s = state;</span><br><span class="line">            if (s &gt;= INTERRUPTING)</span><br><span class="line">                handlePossibleCancellationInterrupt(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>并调用了c.call()方法,而mFuture初始化时传入了一个callable,也就是调用的这个callable的call方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public FutureTask(Callable&lt;V&gt; callable) &#123;</span><br><span class="line">        if (callable == null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        this.callable = callable;</span><br><span class="line">        this.state = NEW;       // ensure visibility of callable</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>mFuture在初始化时传进去一个mWorker,也就是一个Callable</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123;</span><br><span class="line">            public Result call() throws Exception &#123;</span><br><span class="line">                mTaskInvoked.set(true);</span><br><span class="line">                Result result = null;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line">                    //noinspection unchecked</span><br><span class="line">                    result = doInBackground(mParams);</span><br><span class="line">                    Binder.flushPendingCommands();</span><br><span class="line">                &#125; catch (Throwable tr) &#123;</span><br><span class="line">                    mCancelled.set(true);</span><br><span class="line">                    throw tr;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    postResult(result);</span><br><span class="line">                &#125;</span><br><span class="line">                return result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure><p>在这里执行了doInBackground(mParams),且是异步执行,在finally中调用了 postResult(result),publishProgress需要手动调用才会执行.</p><p>postResult(result)方法是在异步调用,但方法里的实现使用Handler发送消息到主线程</p><pre><code>private Result postResult(Result result) {    @SuppressWarnings(&quot;unchecked&quot;)    Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT,            new AsyncTaskResult&lt;Result&gt;(this, result));    message.sendToTarget();    return result;}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private static class InternalHandler extends Handler &#123;</span><br><span class="line">        public InternalHandler(Looper looper) &#123;</span><br><span class="line">            super(looper);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><pre><code>    @SuppressWarnings({&quot;unchecked&quot;, &quot;RawUseOfParameterizedType&quot;})    @Override    public void handleMessage(Message msg) {        AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj;        switch (msg.what) {            case MESSAGE_POST_RESULT:                // There is only one result                result.mTask.finish(result.mData[0]);                break;            case MESSAGE_POST_PROGRESS:                result.mTask.onProgressUpdate(result.mData);                break;        }    }}</code></pre><p>最终在主线程中回调了publishProgress和onPostExecute(result)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@WorkerThread</span><br><span class="line">    protected final void publishProgress(Progress... values) &#123;</span><br><span class="line">        if (!isCancelled()) &#123;</span><br><span class="line">            getHandler().obtainMessage(MESSAGE_POST_PROGRESS,</span><br><span class="line">                    new AsyncTaskResult&lt;Progress&gt;(this, values)).sendToTarget();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><pre><code>private void finish(Result result) {    if (isCancelled()) {        onCancelled(result);    } else {        onPostExecute(result);    }    mStatus = Status.FINISHED;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于面试(一)</title>
      <link href="/2019/07/19/%E5%85%B3%E4%BA%8E%E9%9D%A2%E8%AF%95(%E4%B8%80)/"/>
      <url>/2019/07/19/%E5%85%B3%E4%BA%8E%E9%9D%A2%E8%AF%95(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<h2 id="优化篇"><a href="#优化篇" class="headerlink" title="优化篇"></a>优化篇</h2><h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><ol><li>内部类隐性的持有外部类的引用导致内存泄漏:常见的如使用handler时,直接new创建对象,当页面关闭时,如果handler还在运行时会持有activity的引用,导致activity得不到释放,从而引起内存泄漏。<br> 解决方法:使用静态内部类,然后用弱引用持有外部类的引用 <a id="more"></a></li><li>静态变量引起的内存泄漏:静态变量的生命周期和应用的生命周期一样长,如果用静态变量引用了某个activity的实例会导致activity得不到释放,<br> 解决方法:将activity的引用改为application的引用</li><li>资源对象未关闭:对于使用了BraodcastReceiver，ContentObserver，File，Cursor，Stream，Bitmap等资源的代码，应该在Activity销毁时及时关闭或者注销，否则这些资源将不会被回收，造成内存泄漏</li><li>集合中对象没有清理造成的内存泄漏,在实际开发过程中难免会有把对象添加到集合容器（比如 ArrayList）中的需求，如果在一个对象使用结束之后未将该对象从该容器中移除掉，就会造成该对象不能被正确回收，从而造成内存泄漏，解决办法当然就是在使用完之后将该对象从容器中移除。</li><li>webview引起的内存泄漏主要是因为org.chromium.android_webview.AwContents 类中注册了component callbacks，但是未正常反注册而导致的。让onDetachedFromWindow先走，在主动调用destroy()之前，把webview从它的parent上面移除掉(Basewebfragment onDestroy())</li></ol><h3 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h3><ol><li><p>降低运行时内存:<img src="https://coolyun1.oss-cn-shenzhen.aliyuncs.com/20190719141209.png" alt><br> 降低运行时内存可以分为两部分:</p><ul><li>减小apk体积:去除无用的代码和资源,尽量复用资源,对图片资源进行压缩</li><li>Bitmap优化:  统一的图片加载器:图片加载器默认会对图片进行缓存,按view的实际大小进行加载.inSampleSize进行缩放比例,选择合适的bitmap格式(ARGB_8888/RGB_565/ARGB——4444/ALPHA_8)</li></ul></li><li><p>代码优化:考虑使用ArrayMap/SpareseArray　而不是传统的HashMap等数据结构,Android系统未移动系统设计的容器ArrayMap更加高效,占用内存更少,因为HashMap需要一个额外的实例对象来记录Mapping的操作.而SparesArray高效的避免了key和value的自动装箱,而且避免了装箱后的拆箱</p></li><li><p>在onDraw这种频繁调用的方法要避免对象的创建操作,它会迅速增加内存的使用,引起频繁gc,甚至内存抖动.</p></li><li><p>SoftReference(软引用)、WeakReference(弱引用)、PhantomReference(虚引用):</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SoftReference：如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。</span><br><span class="line">WeakReference：与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。</span><br><span class="line">PhantomReference：虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之 关联的引用队列中。</span><br></pre></td></tr></table></figure></li><li><p>考虑第三方库的大小，如果会和现有的代码或其他库的代码重复，考虑不要真个引入而是把库的代码精简之后再引入。</p></li></ol><h3 id="流畅优化"><a href="#流畅优化" class="headerlink" title="流畅优化"></a>流畅优化</h3><ol><li>界面绘制:主要原因是绘制的层级深,页面复杂,刷新不合理<ul><li>布局服用,使用标签重用layout;提高显示速度,使用延迟view加载;减少层级,使用标签替换父级布局;wrap_content,会增加measure计算成本;删除空间中无用属性.   </li></ul></li><li>数据处理:导致这种卡顿场景的原因在于数据处理量太大,一般分三种情况:一是数据处理在UI线程,二是数据处理占用的cpu高,导致主线程拿不到时间片,三是内存增加导致GC频繁,从而引起卡顿</li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.jianshu.com/p/bdc88955961c" target="_blank" rel="noopener">Android内存泄漏的检测与分析以及解决方案小结</a><br><a href="https://www.jianshu.com/p/8ee81d5ff770" target="_blank" rel="noopener">谈一谈Android内存优化那些事（二）Android常用的内存优化方法</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于面试(二)</title>
      <link href="/2019/07/19/%E5%85%B3%E4%BA%8E%E9%9D%A2%E8%AF%95(%E4%BA%8C)/"/>
      <url>/2019/07/19/%E5%85%B3%E4%BA%8E%E9%9D%A2%E8%AF%95(%E4%BA%8C)/</url>
      
        <content type="html"><![CDATA[<h4 id="view的绘制流程"><a href="#view的绘制流程" class="headerlink" title="view的绘制流程"></a>view的绘制流程</h4><p>Android的UI管理系统层级关系<br><img src="https://coolyun1.oss-cn-shenzhen.aliyuncs.com/20190719141337.png" alt><br>    View的绘制过程是从ViewRoot的performTraversals方法开始的，在其内部依次调用View的performMeasure,performLayout,performDraw三个方法。这三个方法分别完成顶级View的measure,layout,draw过程。其中，performMeasure中会调用measure方法，而在measure方法中又会调用onMeausre()方法，然后在onMeaure方法中会对所有的子元素进行measure过程，这时measure流程就从父容器传递到了子元素中，子元素会继续重复父容器的measure过程，如此反复即完成了整个View树结构的遍历，最终 完成View的测量过程。</p><a id="more"></a><pre><code>同理，performLayout和performDraw方法的传递流程和performMeasure类似，但不同的是，performDraw的传递是在draw方法中通过dispatchDraw方法来下发的，不过本质上原理还是一样的。下面给出一张流程图方便大家更好的理解：</code></pre><p><img src="https://coolyun1.oss-cn-shenzhen.aliyuncs.com/20190719141403.png" alt><br>只看一下主要几个方法:</p><ol><li>performMeasure</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) &#123;</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;measure&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public final void measure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">         // 调用onMeasure()</span><br><span class="line">         onMeasure(widthMeasureSpec, heightMeasureSpec); </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">        if (mOrientation == VERTICAL) &#123;</span><br><span class="line">            // 我们以垂直为例</span><br><span class="line">            measureVertical(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            measureHorizontal(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">void measureVertical(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">        // See how tall everyone is. Also remember max width.</span><br><span class="line">        for (int i = 0; i &lt; count; ++i) &#123;</span><br><span class="line">            final View child = getVirtualChildAt(i);</span><br><span class="line">            // 测量子孩子</span><br><span class="line">            measureChildBeforeLayout(child, i, widthMeasureSpec, 0,</span><br><span class="line">                        heightMeasureSpec, usedHeight);</span><br><span class="line"></span><br><span class="line">            final int childHeight = child.getMeasuredHeight();</span><br><span class="line"></span><br><span class="line">            final int totalLength = mTotalLength;</span><br><span class="line">            // 高度是子View的高度不断的叠加</span><br><span class="line">            mTotalLength = Math.max(totalLength, totalLength + childHeight + lp.topMargin +</span><br><span class="line">                       lp.bottomMargin + getNextLocationOffset(child));</span><br><span class="line">        &#125;</span><br><span class="line">        int heightSize = mTotalLength;</span><br><span class="line">        // Check against our minimum height</span><br><span class="line">        heightSize = Math.max(heightSize, getSuggestedMinimumHeight());</span><br><span class="line">        </span><br><span class="line">        // Reconcile our calculated size with the heightMeasureSpec</span><br><span class="line">        int heightSizeAndState = resolveSizeAndState(heightSize, heightMeasureSpec, 0);</span><br><span class="line">        // 设置宽高</span><br><span class="line">        setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState),</span><br><span class="line">                heightSizeAndState);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>ViewGroup在调用onMeasure()方法的时候,会不断的循环测量子view.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void measureChildBeforeLayout(View child, int childIndex,</span><br><span class="line">            int widthMeasureSpec, int totalWidth, int heightMeasureSpec,</span><br><span class="line">            int totalHeight) &#123;</span><br><span class="line">        measureChildWithMargins(child, widthMeasureSpec, totalWidth,</span><br><span class="line">                heightMeasureSpec, totalHeight);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">protected void measureChildWithMargins(View child,</span><br><span class="line">            int parentWidthMeasureSpec, int widthUsed,</span><br><span class="line">            int parentHeightMeasureSpec, int heightUsed) &#123;</span><br><span class="line">        final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</span><br><span class="line">        //  getChildMeasureSpec 这个方法非常关键</span><br><span class="line">        final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</span><br><span class="line">                mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin</span><br><span class="line">                        + widthUsed, lp.width);</span><br><span class="line">        final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</span><br><span class="line">                mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin</span><br><span class="line">                        + heightUsed, lp.height);</span><br><span class="line"></span><br><span class="line">        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>三种测量方式:<br><img src="https://coolyun1.oss-cn-shenzhen.aliyuncs.com/20190719141441.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">public static int getChildMeasureSpec(int spec, int padding, int childDimension) &#123;</span><br><span class="line">        //获取当前Parent View的Mode和Size</span><br><span class="line">        int specMode = MeasureSpec.getMode(spec);</span><br><span class="line">        int specSize = MeasureSpec.getSize(spec);</span><br><span class="line">        //获取Parent size与padding差值（也就是Parent剩余大小），若差值小于0直接返回0</span><br><span class="line">        int size = Math.max(0, specSize - padding);</span><br><span class="line">        //定义返回值存储变量</span><br><span class="line">        int resultSize = 0;</span><br><span class="line">        int resultMode = 0;</span><br><span class="line">        //依据当前Parent的Mode进行switch分支逻辑</span><br><span class="line">        switch (specMode) &#123;</span><br><span class="line">        // Parent has imposed an exact size on us</span><br><span class="line">        case MeasureSpec.EXACTLY:</span><br><span class="line">            if (childDimension &gt;= 0) &#123;</span><br><span class="line">                //如果child的layout_w和h属性在xml或者java中给予具体大于等于0的数值</span><br><span class="line">                //设置child的size为真实layout_w和h属性值，mode为EXACTLY</span><br><span class="line">                resultSize = childDimension;</span><br><span class="line">                resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">            &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                // Child wants to be our size. So be it.</span><br><span class="line">                //如果child的layout_wOrh属性在xml或者java中给予MATCH_PARENT</span><br><span class="line">                //设置child的size为size，mode为EXACTLY</span><br><span class="line">                resultSize = size;</span><br><span class="line">                resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">            &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">                // Child wants to determine its own size. It can&apos;t be</span><br><span class="line">                // bigger than us.</span><br><span class="line">                //如果child的layout_wOrh属性在xml或者java中给予WRAP_CONTENT</span><br><span class="line">                //设置child的size为size，mode为AT_MOST</span><br><span class="line">                resultSize = size;</span><br><span class="line">                resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        // Parent has imposed a maximum size on us</span><br><span class="line">        case MeasureSpec.AT_MOST:</span><br><span class="line">            if (childDimension &gt;= 0) &#123;</span><br><span class="line">                // ......</span><br><span class="line">            &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                // Child wants to be our size, but our size is not fixed.</span><br><span class="line">                // Constrain child to not be bigger than us.</span><br><span class="line">                // 如果父 View 是 AT_MOST 就算子 View 是 MATCH_PARENT，</span><br><span class="line">                // 其实子View获得的测量模式还是AT_MOST</span><br><span class="line">                resultSize = size;</span><br><span class="line">                resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">            &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">                // Child wants to determine its own size. It can&apos;t be</span><br><span class="line">                // bigger than us.</span><br><span class="line">                resultSize = size;</span><br><span class="line">                resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">            // ......</span><br><span class="line">        &#125;</span><br><span class="line">        //noinspection ResourceType</span><br><span class="line">        return MeasureSpec.makeMeasureSpec(resultSize, resultMode);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>View的绘制流程第一步是onMeasure()，该方法用来测量和指定布局到底占多大的宽高，因为控件的宽高是由父布局和本身来决定的，所以测量是不断的往内走，而最终确定宽高是由内不断的往外走，是递归的方式。</p><ol start="2"><li>performLayout</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private void performLayout(WindowManager.LayoutParams lp, int desiredWindowWidth,</span><br><span class="line">            int desiredWindowHeight) &#123;</span><br><span class="line">        final View host = mView;</span><br><span class="line">        // 调用layout()方法</span><br><span class="line">        host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void layout(int l, int t, int r, int b) &#123;</span><br><span class="line">        onLayout(changed, l, t, r, b);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    protected void onLayout(boolean changed, int l, int t, int r, int b) &#123;</span><br><span class="line">        if (mOrientation == VERTICAL) &#123;</span><br><span class="line">            // 我们以垂直为例</span><br><span class="line">            layoutVertical(l, t, r, b);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            layoutHorizontal(l, t, r, b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">void layoutVertical(int left, int top, int right, int bottom) &#123;</span><br><span class="line">        final int paddingLeft = mPaddingLeft;</span><br><span class="line"></span><br><span class="line">        int childTop;</span><br><span class="line">        int childLeft;</span><br><span class="line"></span><br><span class="line">        // Where right end of child should go</span><br><span class="line">        //计算父窗口推荐的子View宽度</span><br><span class="line">        final int width = right - left;</span><br><span class="line">        //计算父窗口推荐的子View右侧位置</span><br><span class="line">        int childRight = width - mPaddingRight;</span><br><span class="line"></span><br><span class="line">        // Space available for child</span><br><span class="line">        //child可使用空间大小</span><br><span class="line">        int childSpace = width - paddingLeft - mPaddingRight;</span><br><span class="line">        //通过ViewGroup的getChildCount方法获取ViewGroup的子View个数</span><br><span class="line">        final int count = getVirtualChildCount();</span><br><span class="line">        //获取Gravity属性设置</span><br><span class="line">        final int majorGravity = mGravity &amp; Gravity.VERTICAL_GRAVITY_MASK;</span><br><span class="line">        final int minorGravity = mGravity &amp; Gravity.RELATIVE_HORIZONTAL_GRAVITY_MASK;</span><br><span class="line">        //依据majorGravity计算childTop的位置值</span><br><span class="line">        switch (majorGravity) &#123;</span><br><span class="line">           case Gravity.BOTTOM:</span><br><span class="line">               // mTotalLength contains the padding already</span><br><span class="line">               childTop = mPaddingTop + bottom - top - mTotalLength;</span><br><span class="line">               break;</span><br><span class="line"></span><br><span class="line">               // mTotalLength contains the padding already</span><br><span class="line">           case Gravity.CENTER_VERTICAL:</span><br><span class="line">               childTop = mPaddingTop + (bottom - top - mTotalLength) / 2;</span><br><span class="line">               break;</span><br><span class="line"></span><br><span class="line">           case Gravity.TOP:</span><br><span class="line">           default:</span><br><span class="line">               childTop = mPaddingTop;</span><br><span class="line">               break;</span><br><span class="line">        &#125;</span><br><span class="line">        //重点！！！开始遍历</span><br><span class="line">        for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">            final View child = getVirtualChildAt(i);</span><br><span class="line">            if (child == null) &#123;</span><br><span class="line">                childTop += measureNullChild(i);</span><br><span class="line">            &#125; else if (child.getVisibility() != GONE) &#123;</span><br><span class="line">                //LinearLayout中其子视图显示的宽和高由measure过程来决定的，因此measure过程的意义就是为layout过程提供视图显示范围的参考值</span><br><span class="line">                final int childWidth = child.getMeasuredWidth();</span><br><span class="line">                final int childHeight = child.getMeasuredHeight();</span><br><span class="line">                //获取子View的LayoutParams</span><br><span class="line">                final LinearLayout.LayoutParams lp =</span><br><span class="line">                        (LinearLayout.LayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">                int gravity = lp.gravity;</span><br><span class="line">                if (gravity &lt; 0) &#123;</span><br><span class="line">                    gravity = minorGravity;</span><br><span class="line">                &#125;</span><br><span class="line">                final int layoutDirection = getLayoutDirection();</span><br><span class="line">                final int absoluteGravity = Gravity.getAbsoluteGravity(gravity, layoutDirection);</span><br><span class="line">                //依据不同的absoluteGravity计算childLeft位置</span><br><span class="line">                switch (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) &#123;</span><br><span class="line">                    case Gravity.CENTER_HORIZONTAL:</span><br><span class="line">                        childLeft = paddingLeft + ((childSpace - childWidth) / 2)</span><br><span class="line">                                + lp.leftMargin - lp.rightMargin;</span><br><span class="line">                        break;</span><br><span class="line"></span><br><span class="line">                    case Gravity.RIGHT:</span><br><span class="line">                        childLeft = childRight - childWidth - lp.rightMargin;</span><br><span class="line">                        break;</span><br><span class="line"></span><br><span class="line">                    case Gravity.LEFT:</span><br><span class="line">                    default:</span><br><span class="line">                        childLeft = paddingLeft + lp.leftMargin;</span><br><span class="line">                        break;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (hasDividerBeforeChildAt(i)) &#123;</span><br><span class="line">                    childTop += mDividerHeight;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                childTop += lp.topMargin;</span><br><span class="line">                //通过垂直排列计算调运child的layout设置child的位置</span><br><span class="line">                setChildFrame(child, childLeft, childTop + getLocationOffset(child),</span><br><span class="line">                        childWidth, childHeight);</span><br><span class="line">                childTop += childHeight + lp.bottomMargin + getNextLocationOffset(child);</span><br><span class="line"></span><br><span class="line">                i += getChildrenSkipCount(child, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从上面分析可以看出layout也是从顶层父View向子View的递归调用view.layout方法的过程，即父View根据第一步performMeasure，来获取子View所的布局大小和布局参数，将子View放在合适的位置上，不过这个方法没有再往外走，只是不断的往里面走。</p><ol start="3"><li>performDraw</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">private void performDraw() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            draw(fullRedrawNeeded);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            mIsDrawing = false;</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void draw(boolean fullRedrawNeeded) &#123;</span><br><span class="line">        Surface surface = mSurface;</span><br><span class="line">        if (!surface.isValid()) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if (!drawSoftware(surface, mAttachInfo, xOffset, yOffset, scalingRequired, dirty)) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean drawSoftware(Surface surface, AttachInfo attachInfo, int xoff, int yoff,</span><br><span class="line">            boolean scalingRequired, Rect dirty) &#123;</span><br><span class="line">        // Draw with software renderer.</span><br><span class="line">        final Canvas canvas;</span><br><span class="line">        final int left = dirty.left;</span><br><span class="line">        final int top = dirty.top;</span><br><span class="line">        final int right = dirty.right;</span><br><span class="line">        final int bottom = dirty.bottom;</span><br><span class="line">        canvas = mSurface.lockCanvas(dirty);</span><br><span class="line">        // ... ...</span><br><span class="line">        mView.draw(canvas);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="事件分发"><a href="#事件分发" class="headerlink" title="事件分发"></a>事件分发</h4><ol><li>事件类型(down,up,move,cancel),从手指借出屏幕到手指离开屏幕为一组事件<br><img src="https://coolyun1.oss-cn-shenzhen.aliyuncs.com/20190719141523.png" alt></li><li>事件分发的本质就是将点击事件传递到某个具体的view&amp;处理的整个过程.</li><li>事件在Activity,ViewGroup,View中传递</li><li>事件分发由哪些方法协作完成<br><img src="https://coolyun1.oss-cn-shenzhen.aliyuncs.com/20190719141541.png" alt></li><li>activity的事件分发:<br><img src="https://coolyun1.oss-cn-shenzhen.aliyuncs.com/20190719141600.png" alt><br><img src="https://coolyun1.oss-cn-shenzhen.aliyuncs.com/20190719141630.png" alt></li><li>ViewGroup的事件分发:<br><img src="https://coolyun1.oss-cn-shenzhen.aliyuncs.com/20190719141645.png" alt></li><li>View的事件分发:<br><img src="https://coolyun1.oss-cn-shenzhen.aliyuncs.com/20190719141703.png" alt><br><img src="https://coolyun1.oss-cn-shenzhen.aliyuncs.com/20190719141725.png" alt></li><li>总结<br><img src="https://coolyun1.oss-cn-shenzhen.aliyuncs.com/20190719141805.png" alt></li></ol><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>从Activity到ViewGroup到View. Activity类中添加一下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public boolean onTouchEvent(MotionEvent event) &#123;</span><br><span class="line">        Log.e(&quot;gao&quot;, &quot;onTouchEvent: &quot;+this.getClass().getName());</span><br><span class="line">        return super.onTouchEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onClick(View v) &#123;</span><br><span class="line">        Log.e(&quot;gao&quot;, &quot;onClick: &quot;+this.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean dispatchTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">        Log.e(&quot;gao&quot;, &quot;dispatchTouchEvent: &quot;+this.getClass().getName());</span><br><span class="line">        return super.dispatchTouchEvent(ev);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p> ViewGroup中添加以下代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public boolean dispatchTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">        Log.e(&quot;gao&quot;, &quot;dispatchTouchEvent: &quot;+this.getClass().getName());</span><br><span class="line">        return super.dispatchTouchEvent(ev);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean onInterceptTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">        Log.e(&quot;gao&quot;, &quot;onInterceptTouchEvent: &quot;+this.getClass().getName());</span><br><span class="line">        return super.onInterceptTouchEvent(ev);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean onTouchEvent(MotionEvent event) &#123;</span><br><span class="line">        Log.e(&quot;gao&quot;, &quot;onTouchEvent: &quot;+this.getClass().getName());</span><br><span class="line">        return super.onTouchEvent(event);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>View中添加以下代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public boolean onTouchEvent(MotionEvent event) &#123;</span><br><span class="line">        Log.e(&quot;gao&quot;, &quot;onTouchEvent: &quot;+this.getClass().getName());</span><br><span class="line">        return super.onTouchEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean dispatchTouchEvent(MotionEvent event) &#123;</span><br><span class="line">        Log.e(&quot;gao&quot;, &quot;dispatchTouchEvent: &quot;+this.getClass().getName());</span><br><span class="line">        return super.dispatchTouchEvent(event);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>  默认情况下调用顺序:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">04-17 08:03:09.766 2887-2887/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class="line">04-17 08:03:09.767 2887-2887/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class="line">04-17 08:03:09.767 2887-2887/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class="line">04-17 08:03:09.767 2887-2887/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn</span><br><span class="line">04-17 08:03:09.767 2887-2887/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn</span><br><span class="line">04-17 08:03:09.786 2887-2887/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class="line">04-17 08:03:09.786 2887-2887/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class="line">04-17 08:03:09.889 2887-2887/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class="line">04-17 08:03:09.889 2887-2887/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br></pre></td></tr></table></figure><p>view中touchEvent改为true</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">04-17 08:06:14.757 2992-2992/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class="line">04-17 08:06:14.757 2992-2992/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class="line">04-17 08:06:14.757 2992-2992/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class="line">04-17 08:06:14.757 2992-2992/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn</span><br><span class="line">04-17 08:06:14.757 2992-2992/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn</span><br><span class="line">04-17 08:06:14.757 2992-2992/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class="line">04-17 08:06:14.757 2992-2992/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class="line">04-17 08:06:14.757 2992-2992/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class="line">04-17 08:06:14.757 2992-2992/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn</span><br><span class="line">04-17 08:06:14.757 2992-2992/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn</span><br></pre></td></tr></table></figure><p>事件传到View后不再往外传,因为已经被消费了 方法都调用了两遍是因为接收了down事件之后,up事件也传过来接收了</p><p>view中touchEvent改为false</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">04-17 08:23:47.369 3622-3622/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class="line">04-17 08:23:47.370 3622-3622/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class="line">04-17 08:23:47.370 3622-3622/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class="line">04-17 08:23:47.370 3622-3622/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn</span><br><span class="line">04-17 08:23:47.370 3622-3622/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn</span><br><span class="line">04-17 08:23:47.370 3622-3622/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class="line">04-17 08:23:47.370 3622-3622/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class="line">04-17 08:23:47.505 3622-3622/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class="line">04-17 08:23:47.505 3622-3622/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br></pre></td></tr></table></figure><p>View的dispatchTouchEvent改为true</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">04-17 08:26:52.930 3721-3721/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class="line">04-17 08:26:52.930 3721-3721/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class="line">04-17 08:26:52.930 3721-3721/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class="line">04-17 08:26:52.930 3721-3721/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn</span><br></pre></td></tr></table></figure><p>不再分发,不消费,会接收后续事件</p><p>View的dispatchTouchEvent改为false</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">04-17 08:29:02.066 3822-3822/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class="line">04-17 08:29:02.067 3822-3822/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class="line">04-17 08:29:02.067 3822-3822/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class="line">04-17 08:29:02.067 3822-3822/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn</span><br><span class="line">04-17 08:29:02.067 3822-3822/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class="line">04-17 08:29:02.067 3822-3822/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class="line">04-17 08:29:02.176 3822-3822/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class="line">04-17 08:29:02.176 3822-3822/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br></pre></td></tr></table></figure><p>不再分发.会传给外层布局的onTouchEvent进行消费,如果都不进行消费,则后续事件不再向内分发.</p><p>只有View的dispatchTouchEvent为默认值时才会调View的onTouchEvent方法.</p><p>ViewGroup中</p><p>onTouchEvent返回true</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">04-17 08:42:18.120 4533-4533/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class="line">04-17 08:42:18.121 4533-4533/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class="line">04-17 08:42:18.121 4533-4533/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class="line">04-17 08:42:18.122 4533-4533/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn</span><br><span class="line">04-17 08:42:18.122 4533-4533/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn</span><br><span class="line">04-17 08:42:18.122 4533-4533/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class="line">04-17 08:42:35.925 4533-4533/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class="line">04-17 08:42:35.925 4533-4533/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class="line">04-17 08:42:35.925 4533-4533/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br></pre></td></tr></table></figure><p>消费之后会仍会分发给子类,如果子类不消费,后续事件不再分发给子类.</p><p>于此同时把View的onTouchEvent方法改为true</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">04-17 08:44:28.544 4635-4635/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class="line">04-17 08:44:28.545 4635-4635/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class="line">04-17 08:44:28.545 4635-4635/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class="line">04-17 08:44:28.545 4635-4635/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn</span><br><span class="line">04-17 08:44:28.545 4635-4635/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn</span><br><span class="line">04-17 08:44:34.966 4635-4635/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class="line">04-17 08:44:34.966 4635-4635/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class="line">04-17 08:44:34.966 4635-4635/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class="line">04-17 08:44:34.966 4635-4635/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn</span><br><span class="line">04-17 08:44:34.966 4635-4635/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn</span><br></pre></td></tr></table></figure><p>对ViewGroup的事件消费,且后续事件会传递到View中.</p><p>onTouchEvent返回false</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">04-17 08:46:36.068 4735-4735/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class="line">04-17 08:46:36.068 4735-4735/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class="line">04-17 08:46:36.068 4735-4735/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class="line">04-17 08:46:36.068 4735-4735/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn</span><br><span class="line">04-17 08:46:36.068 4735-4735/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn</span><br><span class="line">04-17 08:46:36.068 4735-4735/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class="line">04-17 08:46:36.068 4735-4735/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class="line">04-17 08:47:04.229 4735-4735/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class="line">04-17 08:47:04.229 4735-4735/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br></pre></td></tr></table></figure><p>不进行消费,当次事件会继续分发,如果子View不进行消费则后续事件不再分发进ViewGroup,如果子View进行消费,则后续事件仍会分发,只是不再经过ViewGroup的OntouchEvent()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">04-17 08:50:15.560 5023-5023/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class="line">04-17 08:50:15.560 5023-5023/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class="line">04-17 08:50:15.560 5023-5023/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class="line">04-17 08:50:15.560 5023-5023/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn</span><br><span class="line">04-17 08:50:15.560 5023-5023/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn</span><br><span class="line">04-17 08:50:19.491 5023-5023/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class="line">04-17 08:50:19.491 5023-5023/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class="line">04-17 08:50:19.491 5023-5023/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class="line">04-17 08:50:19.491 5023-5023/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn</span><br><span class="line">04-17 08:50:19.491 5023-5023/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn</span><br></pre></td></tr></table></figure><p>onInterceptTouchEvent返回true</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">04-17 08:53:53.191 5127-5127/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class="line">04-17 08:53:53.193 5127-5127/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class="line">04-17 08:53:53.193 5127-5127/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class="line">04-17 08:53:53.193 5127-5127/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class="line">04-17 08:53:53.193 5127-5127/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class="line">04-17 08:54:08.389 5127-5127/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class="line">04-17 08:54:08.389 5127-5127/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br></pre></td></tr></table></figure><p>拦截后事件不会据需分发,会调用ViewGroup的OntouchVent,如果不进行消费,后续事件不会分发进来.</p><p>与此同时,把onTOuchEvent的返回值改为true</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">04-17 08:56:00.350 5228-5228/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class="line">04-17 08:56:00.350 5228-5228/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class="line">04-17 08:56:00.350 5228-5228/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class="line">04-17 08:56:00.351 5228-5228/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class="line">04-17 08:56:02.535 5228-5228/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class="line">04-17 08:56:02.535 5228-5228/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class="line">04-17 08:56:02.535 5228-5228/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br></pre></td></tr></table></figure><p>拦截之后进行消费,后续事件仍会继续分发,但不再调用拦截方法</p><p>把dispatchTouchEvent返回true</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">04-17 09:00:31.695 5428-5428/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class="line">04-17 09:00:31.695 5428-5428/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class="line">04-17 09:00:31.813 5428-5428/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class="line">04-17 09:00:31.814 5428-5428/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br></pre></td></tr></table></figure><p>往外分发,仍接收后续事件 改为false</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">04-17 09:02:19.810 5529-5529/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class="line">04-17 09:02:19.810 5529-5529/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class="line">04-17 09:02:19.810 5529-5529/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class="line">04-17 09:02:19.928 5529-5529/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class="line">04-17 09:02:19.928 5529-5529/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br></pre></td></tr></table></figure><p>向外分发,不再接收后续事件,会调用Activity的onTouchEvent()</p><p>Activity中</p><p>dispatchTouchEvent返回true或false</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">04-17 09:08:04.216 5728-5728/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class="line">04-17 09:08:04.333 5728-5728/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br></pre></td></tr></table></figure><p>onTouchEvent()改为true</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">04-17 09:09:23.950 5931-5931/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class="line">04-17 09:09:23.950 5931-5931/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class="line">04-17 09:09:23.951 5931-5931/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class="line">04-17 09:09:23.951 5931-5931/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn</span><br><span class="line">04-17 09:09:23.951 5931-5931/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn</span><br><span class="line">04-17 09:09:23.951 5931-5931/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class="line">04-17 09:09:23.951 5931-5931/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class="line">04-17 09:09:24.094 5931-5931/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class="line">04-17 09:09:24.094 5931-5931/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br></pre></td></tr></table></figure><p>当次事件会继续分发,如果没有子控件消费,后续事件不再分发.直接调用onTouchEvent,</p><p>于此同时把View中的onTouchEvent方法返回true</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">04-17 09:15:08.467 6031-6031/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class="line">04-17 09:15:08.467 6031-6031/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class="line">04-17 09:15:08.467 6031-6031/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class="line">04-17 09:15:08.467 6031-6031/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn</span><br><span class="line">04-17 09:15:08.467 6031-6031/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn</span><br><span class="line">04-17 09:15:11.154 6031-6031/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class="line">04-17 09:15:11.154 6031-6031/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class="line">04-17 09:15:11.154 6031-6031/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class="line">04-17 09:15:11.154 6031-6031/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn</span><br><span class="line">04-17 09:15:11.154 6031-6031/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn</span><br></pre></td></tr></table></figure><p>View会先于Activity消费事件,且后续事件会继续分发到View</p><p>把Activity的onTouchEvent()置为false,且子类不消费事件,则当次事件继续分发,后续事件不再分发,直接调用Activity的onTouchEvent方法.</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://www.jianshu.com/p/1075d7d521ec" target="_blank" rel="noopener">源码解析 - View的绘制流程</a><br><a href="https://www.jianshu.com/p/56006bc13dcf" target="_blank" rel="noopener">Android 自定义View——View的绘制流程</a><br><a href="https://www.jianshu.com/p/38015afcdb58" target="_blank" rel="noopener">Android事件分发机制详解：史上最全面、最易懂</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/07/11/hello-world/"/>
      <url>/2019/07/11/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><a id="more"></a><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
