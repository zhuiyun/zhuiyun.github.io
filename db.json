{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/material-x/source/style.less","path":"style.less","modified":0,"renderable":1},{"_id":"themes/material-x/source/fonts/Monaco.ttf","path":"fonts/Monaco.ttf","modified":0,"renderable":1},{"_id":"themes/material-x/source/js/app.js","path":"js/app.js","modified":0,"renderable":1},{"_id":"themes/material-x/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/material-x/source/js/volantis.js","path":"js/volantis.js","modified":0,"renderable":1},{"_id":"themes/material-x/source/fonts/Skranji-Regular.ttf","path":"fonts/Skranji-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/material-x/source/fonts/Ubuntu-Regular.ttf","path":"fonts/Ubuntu-Regular.ttf","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"bbb4832de243e5305e0b95e1cbf6d0f671ba9634","modified":1564567100000},{"_id":"themes/material-x/.DS_Store","hash":"dbb1962611cd9b9bca902bc93995a332eebac9fb","modified":1563514505000},{"_id":"themes/material-x/.gitignore","hash":"f875b6524d4c61e5de0a1d9efdec1fe451d7bc07","modified":1562815652000},{"_id":"themes/material-x/LICENSE","hash":"13b0862f4ed1914abe887a47df2c3ca5adfa8f3f","modified":1562815652000},{"_id":"themes/material-x/README.md","hash":"b497d2c298d6ca35c5ccf9793baa0ceab77b64bf","modified":1562815652000},{"_id":"themes/material-x/_config.yml","hash":"c6b6a190be05e8de2c0a22fafcf7193d118da64b","modified":1563514616000},{"_id":"source/about/index.md","hash":"0f47e6df32f2a3e63aaab17eb5576b07496aad42","modified":1562844321000},{"_id":"source/about/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1562844445000},{"_id":"source/_posts/.DS_Store","hash":"1a881fbea95257649fee6d931d8036881b11de74","modified":1563518211000},{"_id":"source/_posts/AndroidStudio命令行乱码.md","hash":"cf90fc545d879118411789bd6439c42457233e71","modified":1565964057000},{"_id":"source/_posts/AsyncTask.md","hash":"16b078016351546ee1c5227e53d3d65cae107b61","modified":1563515191000},{"_id":"source/_posts/hello-world.md","hash":"7f7adb9f53be2dd083c760f02c62f60022cb6908","modified":1563515215000},{"_id":"source/_posts/关于面试(一).md","hash":"97140800eca153ae10f2cc1e8d0757ba9f0f8044","modified":1563516748000},{"_id":"source/_posts/关于面试(二).md","hash":"4ab063ada9210b8dcb8f8b8ad9cb538594c11b40","modified":1563517093000},{"_id":"source/categories/index.md","hash":"5d195c6ea0d59b91bba1a4a325353955c8952a3d","modified":1562844525000},{"_id":"themes/material-x/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1562815652000},{"_id":"themes/material-x/.git/FETCH_HEAD","hash":"f688c33219ac35902125efef6aa92d834c4b7fb4","modified":1562816878000},{"_id":"source/tags/index.md","hash":"72e6624218fe991a1a83dabc00b1d729c71c1734","modified":1562844583000},{"_id":"themes/material-x/.git/ORIG_HEAD","hash":"fddac67bd9033ea47aabc6619c1773deb3256755","modified":1562816878000},{"_id":"themes/material-x/.git/config","hash":"c154ce28242e1086bb810b259f1f50738bfce101","modified":1562815652000},{"_id":"themes/material-x/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1562815564000},{"_id":"themes/material-x/.git/index","hash":"ac482a59e5100a889b34937485a7ad030caa126c","modified":1565964984000},{"_id":"themes/material-x/.git/packed-refs","hash":"e6e3f3631c6543e63e6b1f69531c56e4fb6daf1b","modified":1562815652000},{"_id":"themes/material-x/languages/en.yml","hash":"3e0c3b617f282ca66d7cff444c9671ea7bb1a503","modified":1562815652000},{"_id":"themes/material-x/languages/zh-HK.yml","hash":"fb5510c20171654d2ebc1ac780a1d6cc596fbd37","modified":1562815652000},{"_id":"themes/material-x/languages/zh-TW.yml","hash":"b8bc7643f790c9da2ec6741af5eeca3dc2e0417a","modified":1562815652000},{"_id":"themes/material-x/languages/zh-CN.yml","hash":"c3a9d3831f1cef9edd2429b4766c359e21673dde","modified":1562815652000},{"_id":"themes/material-x/layout/.DS_Store","hash":"f68ddfeb479d1d9a3025c758e4d0659e12bb79ac","modified":1563514928000},{"_id":"themes/material-x/layout/category.ejs","hash":"ff5b299f7b0f3668174314c57ffe0389891399a6","modified":1562815652000},{"_id":"themes/material-x/layout/index.ejs","hash":"03ba528ba647d8ad184a2dd08e1c2c3ac4dd7baa","modified":1562815652000},{"_id":"themes/material-x/layout/archive.ejs","hash":"6b36ef79379f65952df9f27475f73d191d22657e","modified":1562815652000},{"_id":"themes/material-x/layout/layout.ejs","hash":"9c262bfa12dd43d434d86deea6adf8dfdf46d5b4","modified":1562815652000},{"_id":"themes/material-x/layout/links.ejs","hash":"65fa60924151666fbb814b958ec9b5b231ab0ab9","modified":1562815652000},{"_id":"themes/material-x/layout/page.ejs","hash":"3dd6f14881ac16a8ceb48a1d9f9f5d0377cd082c","modified":1562815652000},{"_id":"themes/material-x/layout/list.ejs","hash":"3466d6dede7aab729b2986c145d95154af0856f2","modified":1562815652000},{"_id":"themes/material-x/layout/post.ejs","hash":"3dd6f14881ac16a8ceb48a1d9f9f5d0377cd082c","modified":1562815652000},{"_id":"themes/material-x/layout/tag.ejs","hash":"ddbfca0cb18d9ceb47611fa3c7e8a8b5ecf31085","modified":1562815652000},{"_id":"themes/material-x/source/style.less","hash":"bd90f674eca5279de970627ce19f20fd784c293a","modified":1562815652000},{"_id":"themes/material-x/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1562815564000},{"_id":"themes/material-x/.git/hooks/fsmonitor-watchman.sample","hash":"f7c0aa40cb0d620ff0bca3efe3521ec79e5d7156","modified":1562815564000},{"_id":"themes/material-x/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1562815564000},{"_id":"themes/material-x/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1562815564000},{"_id":"themes/material-x/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1562815564000},{"_id":"themes/material-x/.git/hooks/pre-commit.sample","hash":"33729ad4ce51acda35094e581e4088f3167a0af8","modified":1562815564000},{"_id":"themes/material-x/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1562815564000},{"_id":"themes/material-x/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1562815564000},{"_id":"themes/material-x/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1562815564000},{"_id":"themes/material-x/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1562815564000},{"_id":"themes/material-x/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1562815564000},{"_id":"themes/material-x/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1562815564000},{"_id":"themes/material-x/.git/logs/HEAD","hash":"6cccd8640b63a28df65a6c21098d40c6253f6bf8","modified":1562815652000},{"_id":"themes/material-x/.github/ISSUE_TEMPLATE/------.md","hash":"cc03dbf4326b9cd0f5a8a024bf6bb622334eca3f","modified":1562815652000},{"_id":"themes/material-x/layout/_cover/search.ejs","hash":"c5c79e41c43efadf41ffc2393152b89213351d00","modified":1562815652000},{"_id":"themes/material-x/layout/_meta/author.ejs","hash":"cebe5d05c7588fb206c64b414b0bad2fca39a7cb","modified":1562815652000},{"_id":"themes/material-x/layout/_meta/categories.ejs","hash":"4b5a6cd4a55742b5963dcd63c3bd9fb8534ba178","modified":1562815652000},{"_id":"themes/material-x/layout/_meta/counter.ejs","hash":"7a22e5cec94673edcb084680df445aa7d800ca2e","modified":1562815652000},{"_id":"themes/material-x/layout/_meta/date.ejs","hash":"0ef066dc7247464359a85d9c39010c1e7e9ffb1d","modified":1562815652000},{"_id":"themes/material-x/layout/_meta/share.ejs","hash":"96cac09c9906283f454039a9f5c0302104338e64","modified":1562815652000},{"_id":"themes/material-x/layout/_meta/tags.ejs","hash":"ca10c85f988b96f332d09d20016c78974cbc925d","modified":1562815652000},{"_id":"themes/material-x/layout/_meta/music.ejs","hash":"1ac33225b2dfc4d5498a86266f97082a8bf135ec","modified":1562815652000},{"_id":"themes/material-x/layout/_meta/thumbnail.ejs","hash":"99f3e0438be97f9462d9a9189117260d811da2e1","modified":1562815652000},{"_id":"themes/material-x/layout/_meta/title.ejs","hash":"58f30ee662f22f55ef9191e06390229beda20694","modified":1562815652000},{"_id":"themes/material-x/layout/_meta/top.ejs","hash":"e4e8bf49173f757ed19ed49d07e0db03f146e989","modified":1562815652000},{"_id":"themes/material-x/layout/_meta/updated.ejs","hash":"2d6e1e234721b930308caf61d2d086213f2389e4","modified":1562815652000},{"_id":"themes/material-x/layout/_partial/article.ejs","hash":"f7e366529355d06cfd4070ed9fae994be09abd25","modified":1562815652000},{"_id":"themes/material-x/layout/_partial/archive.ejs","hash":"ca70dd02c7efb4067c453e8a9414bd3f203db926","modified":1562815652000},{"_id":"themes/material-x/layout/_partial/categories.ejs","hash":"12b2fca703fa56da7a85045bf17499845c3fe5bb","modified":1562815652000},{"_id":"themes/material-x/layout/_partial/cover.ejs","hash":"61430899b26806df450ab75e021534b482ad7746","modified":1562815652000},{"_id":"themes/material-x/layout/_partial/footer.ejs","hash":"ea1e86c615aa8cc6a3f6d073223e9c229a135a26","modified":1562815652000},{"_id":"themes/material-x/layout/_partial/head.ejs","hash":"d4fefdaf1b311daa5a9df2e34fd78320272c505f","modified":1562815652000},{"_id":"themes/material-x/layout/_partial/header.ejs","hash":"846d5496b7a26120ca92e038860707fa70bcaa30","modified":1562815652000},{"_id":"themes/material-x/layout/_partial/mathjax.ejs","hash":"a51a072654643ecf850f813a31dd40d746f8ab96","modified":1562815652000},{"_id":"themes/material-x/layout/_partial/meta.ejs","hash":"9d6a39dd84cc14c31a3fc36e9e0e5ee1f168e53f","modified":1562815652000},{"_id":"themes/material-x/layout/_partial/post.ejs","hash":"6e7a5e3c2894778d8476d01603ab1790f7ccfe00","modified":1562815652000},{"_id":"themes/material-x/layout/_partial/scripts.ejs","hash":"03026fb8f6d18b70f6af6dae2f434ddca98d9813","modified":1562815652000},{"_id":"themes/material-x/layout/_partial/side.ejs","hash":"da987d6feed88023241ea3ee33f390fc47b5c179","modified":1562815652000},{"_id":"themes/material-x/layout/_third-party/aplayer.ejs","hash":"9260682432e0a80261435b4bd27ccf16b8d96fed","modified":1562815652000},{"_id":"themes/material-x/layout/_third-party/clipboard.ejs","hash":"628a0ff18fecc3c866070517aad19366c00f417c","modified":1562815652000},{"_id":"themes/material-x/layout/_third-party/comments.ejs","hash":"e0805f203c7527a852a414ddd21425af4fed0218","modified":1562815652000},{"_id":"themes/material-x/layout/_third-party/fancybox.ejs","hash":"a840db5c132ded3be61e748ef1feadae1435465d","modified":1562815652000},{"_id":"themes/material-x/layout/_third-party/share.ejs","hash":"5b2a57aac6df2be654e45104177a9382641d7584","modified":1562815652000},{"_id":"themes/material-x/layout/_widget/author.ejs","hash":"630967f53c7f8df561022a6230f4791b2c1fde95","modified":1562815652000},{"_id":"themes/material-x/layout/_widget/category.ejs","hash":"a4b3059bb77841a0569243b2ef474ba1fd67ca3a","modified":1562815652000},{"_id":"themes/material-x/layout/_widget/grid.ejs","hash":"33372405602c2bd6dcff42011d14998e5a2b2b70","modified":1562815652000},{"_id":"themes/material-x/layout/_widget/header.ejs","hash":"d542654385da91d26c0647aae0155a7c3fe14d1d","modified":1562815652000},{"_id":"themes/material-x/layout/_widget/list.ejs","hash":"2ce0d61c140852c84d6f0e52b063b0403836be37","modified":1562815652000},{"_id":"themes/material-x/layout/_widget/music.ejs","hash":"a02103653676ab8016b2c4e93c7cd402d4a889bc","modified":1562815652000},{"_id":"themes/material-x/layout/_widget/plain.ejs","hash":"27737e8f046ee3e8907a3ebb86e9800d405a7f4a","modified":1562815652000},{"_id":"themes/material-x/layout/_widget/related_posts.ejs","hash":"aaf497403902a6bd2066c3a7de9b99170914daa4","modified":1562815652000},{"_id":"themes/material-x/layout/_widget/tagcloud.ejs","hash":"b81b89ee0f62768e0cc97cfb2442cdb903ca559a","modified":1562815652000},{"_id":"themes/material-x/layout/_widget/toc.ejs","hash":"dd5f82c8965da414d96d935645fc27f9f3f05566","modified":1562815652000},{"_id":"themes/material-x/source/fonts/Monaco.ttf","hash":"d4de9305ce9e916ece179c3ab3b1faf80cc52bbb","modified":1562815652000},{"_id":"themes/material-x/source/js/app.js","hash":"20ba53cc54035dd091605508155ce54f8491f34e","modified":1562815652000},{"_id":"themes/material-x/source/less/_article.less","hash":"98b835a7bb513a88ec4e5f163923b262eacb640d","modified":1562815652000},{"_id":"themes/material-x/source/less/_archive.less","hash":"13503b9ef5d45782ad44af3b7509191da5824284","modified":1562815652000},{"_id":"themes/material-x/source/js/search.js","hash":"603215c3ae9d2f3c019753dd6c9d228302505bb3","modified":1562815652000},{"_id":"themes/material-x/source/less/_color.less","hash":"95b8a3a4d51a13ef231a498d916aa026470663dd","modified":1562815652000},{"_id":"themes/material-x/source/less/_defines.less","hash":"59912db57e6051debd70487848501e6ad0a016ed","modified":1562815652000},{"_id":"themes/material-x/source/less/_base.less","hash":"f56fe042567bc149eed3b29fe09618c60b0d6733","modified":1562815652000},{"_id":"themes/material-x/source/less/_fonts.less","hash":"0d98499e28ecce54c3e2a2f4f09011c24c4307e9","modified":1562815652000},{"_id":"themes/material-x/source/less/_footer.less","hash":"f53de1b635591582ec9b1ec74249a622fc2cb8fa","modified":1562815652000},{"_id":"themes/material-x/source/less/_links.less","hash":"13d1ba7fa0a43b00dee925160c108f01eb212285","modified":1562815652000},{"_id":"themes/material-x/source/less/_header.less","hash":"9bb49870c459318e1dbb1302ad35645befbf9896","modified":1562815652000},{"_id":"themes/material-x/source/less/_layout.less","hash":"d44abc94ffe5e4f70ecc8e5861ae05fb49f1da88","modified":1562815652000},{"_id":"themes/material-x/source/less/_main.less","hash":"a4898d344e60c08249750b5eca3c6dbd11e2a4e3","modified":1562815652000},{"_id":"themes/material-x/source/less/_normalize.less","hash":"f092813604db20a84c62ef889411598e78d14599","modified":1562815652000},{"_id":"themes/material-x/source/less/_search.less","hash":"7d8470699ed21c63ad6281d5934cadead109d97c","modified":1562815652000},{"_id":"themes/material-x/source/less/_pagination.less","hash":"165e2c369faf70858b731bb6d483d8991259887e","modified":1562815652000},{"_id":"themes/material-x/source/less/_side.less","hash":"85b5a080defb327d4739356ec872b4e6346c12d2","modified":1562815652000},{"_id":"themes/material-x/source/less/_tog.less","hash":"73e72c4efd04a8721a87002de1a8a0201e1f5564","modified":1562815652000},{"_id":"themes/material-x/source/less/_typo.less","hash":"6a93f9fab3e1dfac4dc80dd77bf6b1223b5fb058","modified":1562815652000},{"_id":"themes/material-x/source/less/_toc.less","hash":"6d8c644aebe6fd6d9b657bd2b037ab4296fe80b1","modified":1562815652000},{"_id":"themes/material-x/.git/refs/heads/master","hash":"fddac67bd9033ea47aabc6619c1773deb3256755","modified":1562815652000},{"_id":"themes/material-x/source/js/volantis.js","hash":"28fcd2db5a696d2f327eb53d95e711c3f2574240","modified":1562815652000},{"_id":"themes/material-x/.git/objects/pack/pack-49bcddfe2d4d685b7b3d747af9373398ae74fbc7.idx","hash":"d7fd532551e371a1febc5f440a83f011a4943589","modified":1562815652000},{"_id":"themes/material-x/source/fonts/Skranji-Regular.ttf","hash":"485dc033e34a5a92a45ffe5839514f0471b18208","modified":1562815652000},{"_id":"themes/material-x/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1562815652000},{"_id":"themes/material-x/.git/logs/refs/heads/master","hash":"6cccd8640b63a28df65a6c21098d40c6253f6bf8","modified":1562815652000},{"_id":"themes/material-x/.git/logs/refs/remotes/origin/HEAD","hash":"6cccd8640b63a28df65a6c21098d40c6253f6bf8","modified":1562815652000},{"_id":"themes/material-x/source/fonts/Ubuntu-Regular.ttf","hash":"b100b2ed912a91e4d0a7c5f5309fe8ad7b3a2dd8","modified":1562815652000},{"_id":"themes/material-x/.git/objects/pack/pack-49bcddfe2d4d685b7b3d747af9373398ae74fbc7.pack","hash":"f5f8ed310177a80ef10b00d78e6b20bbd023b7b7","modified":1562815652000},{"_id":"public/content.json","hash":"ca156d48c2d2869e0a76531ffb48701dcde85ab2","modified":1567520824277},{"_id":"public/search.xml","hash":"1c8e4902c2a5e15bf8fb49ba541838dea9c85399","modified":1567520824277},{"_id":"public/about/index.html","hash":"028deff7436eb8fbf9ceb3ddd5509aa59e7472b2","modified":1567520824426},{"_id":"public/tags/index.html","hash":"06096051e47aad394f2a2cabe271f80ec3d99e67","modified":1567520824426},{"_id":"public/categories/index.html","hash":"181e6ca019342a977cd47ff9eb16b5bb2b99f923","modified":1567520824426},{"_id":"public/2019/07/31/AndroidStudio命令行乱码/index.html","hash":"ca36888afb759ec37a8cd2cd03f098463044fc97","modified":1567520824426},{"_id":"public/2019/07/19/AsyncTask/index.html","hash":"134066a0a1345d43c38b27a841337a7c5638307c","modified":1567520824427},{"_id":"public/2019/07/19/关于面试(一)/index.html","hash":"0712984bb8c73229b1da84b5bfdb354b0c097cc7","modified":1567520824427},{"_id":"public/2019/07/19/关于面试(二)/index.html","hash":"023e9a5908cf3050dde543cace5e1349bc848dec","modified":1567520824427},{"_id":"public/2019/07/11/hello-world/index.html","hash":"36f0818a00564e179831414d10bd662f8d27ede0","modified":1567520824427},{"_id":"public/categories/Android/index.html","hash":"c80f5477c3566445ea8a43707192352a9c83c31a","modified":1567520824427},{"_id":"public/archives/index.html","hash":"fed93a50e7fdd700a7e84ffbb76905184785a418","modified":1567520824427},{"_id":"public/archives/2019/index.html","hash":"6ff8c5492c7c9f4217fdaea7172fe3041a607f75","modified":1567520824427},{"_id":"public/archives/2019/07/index.html","hash":"8d153da511e169c04b13e696bef9ac570b1753f4","modified":1567520824427},{"_id":"public/index.html","hash":"0b9839448e5ce2243a4e9d1c2d30dc683ea0a074","modified":1567520824427},{"_id":"public/tags/Android/index.html","hash":"afa52cce56b196b36cdb8dd3aebbc0806bb949d9","modified":1567520824427},{"_id":"public/tags/问题解决/index.html","hash":"d2ae90a346f0305bfa437b4ae0e106d0fd417da7","modified":1567520824427},{"_id":"public/tags/源码/index.html","hash":"368a3c539b1681065ce104042506b9bf696f980e","modified":1567520824427},{"_id":"public/tags/面试/index.html","hash":"b6e7a9659c04531d2f5915cdc41717ff29e6e4d9","modified":1567520824428},{"_id":"public/fonts/Monaco.ttf","hash":"d4de9305ce9e916ece179c3ab3b1faf80cc52bbb","modified":1567520824439},{"_id":"public/js/app.js","hash":"20ba53cc54035dd091605508155ce54f8491f34e","modified":1567520824442},{"_id":"public/fonts/Skranji-Regular.ttf","hash":"485dc033e34a5a92a45ffe5839514f0471b18208","modified":1567520824444},{"_id":"public/js/search.js","hash":"603215c3ae9d2f3c019753dd6c9d228302505bb3","modified":1567520824445},{"_id":"public/fonts/Ubuntu-Regular.ttf","hash":"b100b2ed912a91e4d0a7c5f5309fe8ad7b3a2dd8","modified":1567520824699},{"_id":"public/style.css","hash":"0c18ee03fdd12436af539266a6d5aa134ec46ed1","modified":1567520824700},{"_id":"public/js/volantis.js","hash":"28fcd2db5a696d2f327eb53d95e711c3f2574240","modified":1567520824706}],"Category":[{"name":"Android","_id":"ck03xfcah00044frr24rapgjr"}],"Data":[],"Page":[{"layout":"page","title":"关于","body":["article","grid","comments"],"valine":{"placeholder":"有什么想对我说的呢？"},"sidebar":false,"_content":"\n\n","source":"about/index.md","raw":"\n---\nlayout: page\ntitle: 关于\nbody: [article, grid, comments]\nvaline:\n  placeholder: 有什么想对我说的呢？\nsidebar: false\n---\n\n\n","date":"2019-09-03T14:25:25.330Z","updated":"2019-07-11T11:25:21.000Z","path":"about/index.html","comments":1,"_id":"ck03xfca900004frrefwdvw6z","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"tag","index":true,"title":"所有标签","_content":"\n","source":"tags/index.md","raw":"---\nlayout: tag\nindex: true\ntitle: 所有标签\n---\n\n","date":"2019-09-03T14:25:25.333Z","updated":"2019-07-11T11:29:43.000Z","path":"tags/index.html","comments":1,"_id":"ck03xfcae00024frr1wv5zg3b","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"category","index":true,"title":"所有分类","_content":"\n","source":"categories/index.md","raw":"---\nlayout: category\nindex: true\ntitle: 所有分类\n---\n\n","date":"2019-09-03T14:25:25.332Z","updated":"2019-07-11T11:28:45.000Z","path":"categories/index.html","comments":1,"_id":"ck03xfcaj00064frrf8paa2sp","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"layout":"post","title":"解决AndroidStudio的命令行乱码","date":"2019-07-30T16:00:00.000Z","body":["article","comments"],"toc":true,"_content":"\n#解决AndroidStudio命令行乱码\n\n## 现象\n用的macbook,下载了iTerm2后,根据网上博客配置了一些属性,之后打开Androidstudio时,发现命令行乱码,鼓捣了一阵终于搞定\n <!-- more -->\n## 解决\n这个情况主要是修改了命令行的字体,但Androidstudio中有默认字体,两者不是同一个造成的,只需修改其中之一即可,我改的是Androidstudio.修改位置如下图:\n![](https://i.loli.net/2019/07/31/5d4168e4e131675700.png)\n需要和iTerm2中字体一致\n![](https://i.loli.net/2019/07/31/5d41688ed76d781045.png)\n\n","source":"_posts/AndroidStudio命令行乱码.md","raw":"---\nlayout: post\ntitle: 解决AndroidStudio的命令行乱码\ndate: 2019.7.31\nbody: [article,  comments]\ntoc: true\ntag: [Android,问题解决]\ncategories: [Android]\n---\n\n#解决AndroidStudio命令行乱码\n\n## 现象\n用的macbook,下载了iTerm2后,根据网上博客配置了一些属性,之后打开Androidstudio时,发现命令行乱码,鼓捣了一阵终于搞定\n <!-- more -->\n## 解决\n这个情况主要是修改了命令行的字体,但Androidstudio中有默认字体,两者不是同一个造成的,只需修改其中之一即可,我改的是Androidstudio.修改位置如下图:\n![](https://i.loli.net/2019/07/31/5d4168e4e131675700.png)\n需要和iTerm2中字体一致\n![](https://i.loli.net/2019/07/31/5d41688ed76d781045.png)\n\n","slug":"AndroidStudio命令行乱码","published":1,"updated":"2019-08-16T14:00:57.000Z","comments":1,"photos":[],"link":"","_id":"ck03xfcaa00014frr37z3ekoj","content":"<p>#解决AndroidStudio命令行乱码</p>\n<h2 id=\"现象\"><a href=\"#现象\" class=\"headerlink\" title=\"现象\"></a>现象</h2><p>用的macbook,下载了iTerm2后,根据网上博客配置了一些属性,之后打开Androidstudio时,发现命令行乱码,鼓捣了一阵终于搞定<br> <a id=\"more\"></a></p>\n<h2 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h2><p>这个情况主要是修改了命令行的字体,但Androidstudio中有默认字体,两者不是同一个造成的,只需修改其中之一即可,我改的是Androidstudio.修改位置如下图:<br><img src=\"https://i.loli.net/2019/07/31/5d4168e4e131675700.png\" alt><br>需要和iTerm2中字体一致<br><img src=\"https://i.loli.net/2019/07/31/5d41688ed76d781045.png\" alt></p>\n","site":{"data":{}},"excerpt":"<p>#解决AndroidStudio命令行乱码</p>\n<h2 id=\"现象\"><a href=\"#现象\" class=\"headerlink\" title=\"现象\"></a>现象</h2><p>用的macbook,下载了iTerm2后,根据网上博客配置了一些属性,之后打开Androidstudio时,发现命令行乱码,鼓捣了一阵终于搞定<br>","more":"</p>\n<h2 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h2><p>这个情况主要是修改了命令行的字体,但Androidstudio中有默认字体,两者不是同一个造成的,只需修改其中之一即可,我改的是Androidstudio.修改位置如下图:<br><img src=\"https://i.loli.net/2019/07/31/5d4168e4e131675700.png\" alt><br>需要和iTerm2中字体一致<br><img src=\"https://i.loli.net/2019/07/31/5d41688ed76d781045.png\" alt></p>"},{"layout":"post","title":"AsyncTask源码分析","date":"2019-07-18T16:00:00.000Z","body":["article","comments"],"toc":true,"_content":"\n先看一下用法\n\n        AsyncTask<Void, Void, Void> asyncTask = new AsyncTask<Void, Void, Void>() {\n\n            @Override\n            protected Void doInBackground(Void... voids) {\n                return null;\n            }\n        };\n        asyncTask.execute();\n源码中这是一个抽象类,必须自己去实现,才能使用\n<!-- more -->\n\n```\npublic abstract class AsyncTask<Params, Progress, Result>\n\n```\n\n有三个参数,第一个是你要传什么东西异步使用,一般可能是网址,不需要传可以填void,第二个参数为执行进度,不需要也可以填void,第三个是返回数据,也可以填void.\n\n用asyncTask.execute()执行AsyncTask,括号中填的跟第一个参数对应. excute()方法调用了这个方法,还是在主线程中\n\n    @MainThread\n    public final AsyncTask<Params, Progress, Result> execute(Params... params) {\n        return executeOnExecutor(sDefaultExecutor, params);\n    }\n之后调用\n\n    @MainThread\n    public final AsyncTask<Params, Progress, Result> executeOnExecutor(Executor exec,\n            Params... params) {\n        if (mStatus != Status.PENDING) {\n            switch (mStatus) {\n                case RUNNING:\n                    throw new IllegalStateException(\"Cannot execute task:\"\n                            + \" the task is already running.\");\n                case FINISHED:\n                    throw new IllegalStateException(\"Cannot execute task:\"\n                            + \" the task has already been executed \"\n                            + \"(a task can be executed only once)\");\n            }\n        }\n\n        mStatus = Status.RUNNING;\n\n        onPreExecute();\n\n        mWorker.mParams = params;\n        exec.execute(mFuture);\n\n        return this;\n    }\n这个方法中判断了mStatus的状态,里面有两个异常抛出,可以看出一个任务只能执行一次. 而mStatus在初始化时置为了Status.PENDING,所以不会进入if (mStatus != Status.PENDING),会改变mStatus状态:mStatus = Status.RUNNING;\n\nprivate volatile Status mStatus = Status.PENDING;\n接下来调用onPreExecute(),点进去看一下这个方法.\n\n    @MainThread\n    protected void onPreExecute() {\n    }\n这方法是空实现,注解表示此时仍在主线程中,之后调用\n\n```\nexec.execute(mFuture);\nvoid execute(Runnable command);\n```\n\nexec是之前的sDefaultExecutor\n\n```\nprivate static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR;\n\npublic static final Executor SERIAL_EXECUTOR = new SerialExecutor();\n\n\nprivate static class SerialExecutor implements Executor {\n        final ArrayDeque<Runnable> mTasks = new ArrayDeque<Runnable>();\n        Runnable mActive;\n```\n\n        public synchronized void execute(final Runnable r) {\n            mTasks.offer(new Runnable() {\n                public void run() {\n                    try {\n                        r.run();\n                    } finally {\n                        scheduleNext();\n                    }\n                }\n            });\n            if (mActive == null) {\n                scheduleNext();\n            }\n        }\n\n        protected synchronized void scheduleNext() {\n            if ((mActive = mTasks.poll()) != null) {\n                THREAD_POOL_EXECUTOR.execute(mActive);\n            }\n        }\n    }\nscheduleNext()在这个方法中,由线程池来执行任务\n\n```\nprotected synchronized void scheduleNext() {\n            if ((mActive = mTasks.poll()) != null) {\n                THREAD_POOL_EXECUTOR.execute(mActive);\n            }\n        }\n        \n\npublic E poll() {\n        return pollFirst();\n    }\n\n```\n 也就是会调出第一个任务来执行\n\nexecute方法 需要一个Runnable,最终调用Runnable的run方法,也就是mFuture的run方法\n\n\n```\npublic void run() {\n        if (state != NEW ||\n            !U.compareAndSwapObject(this, RUNNER, null, Thread.currentThread()))\n            return;\n        try {\n            Callable<V> c = callable;\n            if (c != null && state == NEW) {\n                V result;\n                boolean ran;\n                try {\n                    result = c.call();\n                    ran = true;\n                } catch (Throwable ex) {\n                    result = null;\n                    ran = false;\n                    setException(ex);\n                }\n                if (ran)\n                    set(result);\n            }\n        } finally {\n            // runner must be non-null until state is settled to\n            // prevent concurrent calls to run()\n            runner = null;\n            // state must be re-read after nulling runner to prevent\n            // leaked interrupts\n            int s = state;\n            if (s >= INTERRUPTING)\n                handlePossibleCancellationInterrupt(s);\n        }\n    }\n\n```\n并调用了c.call()方法,而mFuture初始化时传入了一个callable,也就是调用的这个callable的call方法\n\n\n```\npublic FutureTask(Callable<V> callable) {\n        if (callable == null)\n            throw new NullPointerException();\n        this.callable = callable;\n        this.state = NEW;       // ensure visibility of callable\n    }\n\n```\nmFuture在初始化时传进去一个mWorker,也就是一个Callable\n\n\n```\nmWorker = new WorkerRunnable<Params, Result>() {\n            public Result call() throws Exception {\n                mTaskInvoked.set(true);\n                Result result = null;\n                try {\n                    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);\n                    //noinspection unchecked\n                    result = doInBackground(mParams);\n                    Binder.flushPendingCommands();\n                } catch (Throwable tr) {\n                    mCancelled.set(true);\n                    throw tr;\n                } finally {\n                    postResult(result);\n                }\n                return result;\n            }\n        };\n\n```\n在这里执行了doInBackground(mParams),且是异步执行,在finally中调用了 postResult(result),publishProgress需要手动调用才会执行.\n\npostResult(result)方法是在异步调用,但方法里的实现使用Handler发送消息到主线程\n\n    private Result postResult(Result result) {\n        @SuppressWarnings(\"unchecked\")\n        Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT,\n                new AsyncTaskResult<Result>(this, result));\n        message.sendToTarget();\n        return result;\n    }\n\n```\nprivate static class InternalHandler extends Handler {\n        public InternalHandler(Looper looper) {\n            super(looper);\n        }\n\n```\n        @SuppressWarnings({\"unchecked\", \"RawUseOfParameterizedType\"})\n        @Override\n        public void handleMessage(Message msg) {\n            AsyncTaskResult<?> result = (AsyncTaskResult<?>) msg.obj;\n            switch (msg.what) {\n                case MESSAGE_POST_RESULT:\n                    // There is only one result\n                    result.mTask.finish(result.mData[0]);\n                    break;\n                case MESSAGE_POST_PROGRESS:\n                    result.mTask.onProgressUpdate(result.mData);\n                    break;\n            }\n        }\n    }\n最终在主线程中回调了publishProgress和onPostExecute(result)\n\n \n```\n@WorkerThread\n    protected final void publishProgress(Progress... values) {\n        if (!isCancelled()) {\n            getHandler().obtainMessage(MESSAGE_POST_PROGRESS,\n                    new AsyncTaskResult<Progress>(this, values)).sendToTarget();\n        }\n    }\n\n```\n    private void finish(Result result) {\n        if (isCancelled()) {\n            onCancelled(result);\n        } else {\n            onPostExecute(result);\n        }\n        mStatus = Status.FINISHED;\n    }\n\n\n\n\n","source":"_posts/AsyncTask.md","raw":"---\nlayout: post\ntitle: AsyncTask源码分析\ndate: 2019.7.19\nbody: [article,  comments]\ntoc: true\ntag: [Android,源码]\ncategories: [Android]\n---\n\n先看一下用法\n\n        AsyncTask<Void, Void, Void> asyncTask = new AsyncTask<Void, Void, Void>() {\n\n            @Override\n            protected Void doInBackground(Void... voids) {\n                return null;\n            }\n        };\n        asyncTask.execute();\n源码中这是一个抽象类,必须自己去实现,才能使用\n<!-- more -->\n\n```\npublic abstract class AsyncTask<Params, Progress, Result>\n\n```\n\n有三个参数,第一个是你要传什么东西异步使用,一般可能是网址,不需要传可以填void,第二个参数为执行进度,不需要也可以填void,第三个是返回数据,也可以填void.\n\n用asyncTask.execute()执行AsyncTask,括号中填的跟第一个参数对应. excute()方法调用了这个方法,还是在主线程中\n\n    @MainThread\n    public final AsyncTask<Params, Progress, Result> execute(Params... params) {\n        return executeOnExecutor(sDefaultExecutor, params);\n    }\n之后调用\n\n    @MainThread\n    public final AsyncTask<Params, Progress, Result> executeOnExecutor(Executor exec,\n            Params... params) {\n        if (mStatus != Status.PENDING) {\n            switch (mStatus) {\n                case RUNNING:\n                    throw new IllegalStateException(\"Cannot execute task:\"\n                            + \" the task is already running.\");\n                case FINISHED:\n                    throw new IllegalStateException(\"Cannot execute task:\"\n                            + \" the task has already been executed \"\n                            + \"(a task can be executed only once)\");\n            }\n        }\n\n        mStatus = Status.RUNNING;\n\n        onPreExecute();\n\n        mWorker.mParams = params;\n        exec.execute(mFuture);\n\n        return this;\n    }\n这个方法中判断了mStatus的状态,里面有两个异常抛出,可以看出一个任务只能执行一次. 而mStatus在初始化时置为了Status.PENDING,所以不会进入if (mStatus != Status.PENDING),会改变mStatus状态:mStatus = Status.RUNNING;\n\nprivate volatile Status mStatus = Status.PENDING;\n接下来调用onPreExecute(),点进去看一下这个方法.\n\n    @MainThread\n    protected void onPreExecute() {\n    }\n这方法是空实现,注解表示此时仍在主线程中,之后调用\n\n```\nexec.execute(mFuture);\nvoid execute(Runnable command);\n```\n\nexec是之前的sDefaultExecutor\n\n```\nprivate static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR;\n\npublic static final Executor SERIAL_EXECUTOR = new SerialExecutor();\n\n\nprivate static class SerialExecutor implements Executor {\n        final ArrayDeque<Runnable> mTasks = new ArrayDeque<Runnable>();\n        Runnable mActive;\n```\n\n        public synchronized void execute(final Runnable r) {\n            mTasks.offer(new Runnable() {\n                public void run() {\n                    try {\n                        r.run();\n                    } finally {\n                        scheduleNext();\n                    }\n                }\n            });\n            if (mActive == null) {\n                scheduleNext();\n            }\n        }\n\n        protected synchronized void scheduleNext() {\n            if ((mActive = mTasks.poll()) != null) {\n                THREAD_POOL_EXECUTOR.execute(mActive);\n            }\n        }\n    }\nscheduleNext()在这个方法中,由线程池来执行任务\n\n```\nprotected synchronized void scheduleNext() {\n            if ((mActive = mTasks.poll()) != null) {\n                THREAD_POOL_EXECUTOR.execute(mActive);\n            }\n        }\n        \n\npublic E poll() {\n        return pollFirst();\n    }\n\n```\n 也就是会调出第一个任务来执行\n\nexecute方法 需要一个Runnable,最终调用Runnable的run方法,也就是mFuture的run方法\n\n\n```\npublic void run() {\n        if (state != NEW ||\n            !U.compareAndSwapObject(this, RUNNER, null, Thread.currentThread()))\n            return;\n        try {\n            Callable<V> c = callable;\n            if (c != null && state == NEW) {\n                V result;\n                boolean ran;\n                try {\n                    result = c.call();\n                    ran = true;\n                } catch (Throwable ex) {\n                    result = null;\n                    ran = false;\n                    setException(ex);\n                }\n                if (ran)\n                    set(result);\n            }\n        } finally {\n            // runner must be non-null until state is settled to\n            // prevent concurrent calls to run()\n            runner = null;\n            // state must be re-read after nulling runner to prevent\n            // leaked interrupts\n            int s = state;\n            if (s >= INTERRUPTING)\n                handlePossibleCancellationInterrupt(s);\n        }\n    }\n\n```\n并调用了c.call()方法,而mFuture初始化时传入了一个callable,也就是调用的这个callable的call方法\n\n\n```\npublic FutureTask(Callable<V> callable) {\n        if (callable == null)\n            throw new NullPointerException();\n        this.callable = callable;\n        this.state = NEW;       // ensure visibility of callable\n    }\n\n```\nmFuture在初始化时传进去一个mWorker,也就是一个Callable\n\n\n```\nmWorker = new WorkerRunnable<Params, Result>() {\n            public Result call() throws Exception {\n                mTaskInvoked.set(true);\n                Result result = null;\n                try {\n                    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);\n                    //noinspection unchecked\n                    result = doInBackground(mParams);\n                    Binder.flushPendingCommands();\n                } catch (Throwable tr) {\n                    mCancelled.set(true);\n                    throw tr;\n                } finally {\n                    postResult(result);\n                }\n                return result;\n            }\n        };\n\n```\n在这里执行了doInBackground(mParams),且是异步执行,在finally中调用了 postResult(result),publishProgress需要手动调用才会执行.\n\npostResult(result)方法是在异步调用,但方法里的实现使用Handler发送消息到主线程\n\n    private Result postResult(Result result) {\n        @SuppressWarnings(\"unchecked\")\n        Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT,\n                new AsyncTaskResult<Result>(this, result));\n        message.sendToTarget();\n        return result;\n    }\n\n```\nprivate static class InternalHandler extends Handler {\n        public InternalHandler(Looper looper) {\n            super(looper);\n        }\n\n```\n        @SuppressWarnings({\"unchecked\", \"RawUseOfParameterizedType\"})\n        @Override\n        public void handleMessage(Message msg) {\n            AsyncTaskResult<?> result = (AsyncTaskResult<?>) msg.obj;\n            switch (msg.what) {\n                case MESSAGE_POST_RESULT:\n                    // There is only one result\n                    result.mTask.finish(result.mData[0]);\n                    break;\n                case MESSAGE_POST_PROGRESS:\n                    result.mTask.onProgressUpdate(result.mData);\n                    break;\n            }\n        }\n    }\n最终在主线程中回调了publishProgress和onPostExecute(result)\n\n \n```\n@WorkerThread\n    protected final void publishProgress(Progress... values) {\n        if (!isCancelled()) {\n            getHandler().obtainMessage(MESSAGE_POST_PROGRESS,\n                    new AsyncTaskResult<Progress>(this, values)).sendToTarget();\n        }\n    }\n\n```\n    private void finish(Result result) {\n        if (isCancelled()) {\n            onCancelled(result);\n        } else {\n            onPostExecute(result);\n        }\n        mStatus = Status.FINISHED;\n    }\n\n\n\n\n","slug":"AsyncTask","published":1,"updated":"2019-07-19T05:46:31.000Z","comments":1,"photos":[],"link":"","_id":"ck03xfcaf00034frr2firrwz3","content":"<p>先看一下用法</p>\n<pre><code>AsyncTask&lt;Void, Void, Void&gt; asyncTask = new AsyncTask&lt;Void, Void, Void&gt;() {\n\n    @Override\n    protected Void doInBackground(Void... voids) {\n        return null;\n    }\n};\nasyncTask.execute();</code></pre><p>源码中这是一个抽象类,必须自己去实现,才能使用</p>\n<a id=\"more\"></a>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public abstract class AsyncTask&lt;Params, Progress, Result&gt;</span><br></pre></td></tr></table></figure>\n\n<p>有三个参数,第一个是你要传什么东西异步使用,一般可能是网址,不需要传可以填void,第二个参数为执行进度,不需要也可以填void,第三个是返回数据,也可以填void.</p>\n<p>用asyncTask.execute()执行AsyncTask,括号中填的跟第一个参数对应. excute()方法调用了这个方法,还是在主线程中</p>\n<pre><code>@MainThread\npublic final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) {\n    return executeOnExecutor(sDefaultExecutor, params);\n}</code></pre><p>之后调用</p>\n<pre><code>@MainThread\npublic final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec,\n        Params... params) {\n    if (mStatus != Status.PENDING) {\n        switch (mStatus) {\n            case RUNNING:\n                throw new IllegalStateException(&quot;Cannot execute task:&quot;\n                        + &quot; the task is already running.&quot;);\n            case FINISHED:\n                throw new IllegalStateException(&quot;Cannot execute task:&quot;\n                        + &quot; the task has already been executed &quot;\n                        + &quot;(a task can be executed only once)&quot;);\n        }\n    }\n\n    mStatus = Status.RUNNING;\n\n    onPreExecute();\n\n    mWorker.mParams = params;\n    exec.execute(mFuture);\n\n    return this;\n}</code></pre><p>这个方法中判断了mStatus的状态,里面有两个异常抛出,可以看出一个任务只能执行一次. 而mStatus在初始化时置为了Status.PENDING,所以不会进入if (mStatus != Status.PENDING),会改变mStatus状态:mStatus = Status.RUNNING;</p>\n<p>private volatile Status mStatus = Status.PENDING;<br>接下来调用onPreExecute(),点进去看一下这个方法.</p>\n<pre><code>@MainThread\nprotected void onPreExecute() {\n}</code></pre><p>这方法是空实现,注解表示此时仍在主线程中,之后调用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">exec.execute(mFuture);</span><br><span class=\"line\">void execute(Runnable command);</span><br></pre></td></tr></table></figure>\n\n<p>exec是之前的sDefaultExecutor</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR;</span><br><span class=\"line\"></span><br><span class=\"line\">public static final Executor SERIAL_EXECUTOR = new SerialExecutor();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">private static class SerialExecutor implements Executor &#123;</span><br><span class=\"line\">        final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;();</span><br><span class=\"line\">        Runnable mActive;</span><br></pre></td></tr></table></figure>\n\n<pre><code>    public synchronized void execute(final Runnable r) {\n        mTasks.offer(new Runnable() {\n            public void run() {\n                try {\n                    r.run();\n                } finally {\n                    scheduleNext();\n                }\n            }\n        });\n        if (mActive == null) {\n            scheduleNext();\n        }\n    }\n\n    protected synchronized void scheduleNext() {\n        if ((mActive = mTasks.poll()) != null) {\n            THREAD_POOL_EXECUTOR.execute(mActive);\n        }\n    }\n}</code></pre><p>scheduleNext()在这个方法中,由线程池来执行任务</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protected synchronized void scheduleNext() &#123;</span><br><span class=\"line\">            if ((mActive = mTasks.poll()) != null) &#123;</span><br><span class=\"line\">                THREAD_POOL_EXECUTOR.execute(mActive);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\"></span><br><span class=\"line\">public E poll() &#123;</span><br><span class=\"line\">        return pollFirst();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p> 也就是会调出第一个任务来执行</p>\n<p>execute方法 需要一个Runnable,最终调用Runnable的run方法,也就是mFuture的run方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void run() &#123;</span><br><span class=\"line\">        if (state != NEW ||</span><br><span class=\"line\">            !U.compareAndSwapObject(this, RUNNER, null, Thread.currentThread()))</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            Callable&lt;V&gt; c = callable;</span><br><span class=\"line\">            if (c != null &amp;&amp; state == NEW) &#123;</span><br><span class=\"line\">                V result;</span><br><span class=\"line\">                boolean ran;</span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                    result = c.call();</span><br><span class=\"line\">                    ran = true;</span><br><span class=\"line\">                &#125; catch (Throwable ex) &#123;</span><br><span class=\"line\">                    result = null;</span><br><span class=\"line\">                    ran = false;</span><br><span class=\"line\">                    setException(ex);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                if (ran)</span><br><span class=\"line\">                    set(result);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; finally &#123;</span><br><span class=\"line\">            // runner must be non-null until state is settled to</span><br><span class=\"line\">            // prevent concurrent calls to run()</span><br><span class=\"line\">            runner = null;</span><br><span class=\"line\">            // state must be re-read after nulling runner to prevent</span><br><span class=\"line\">            // leaked interrupts</span><br><span class=\"line\">            int s = state;</span><br><span class=\"line\">            if (s &gt;= INTERRUPTING)</span><br><span class=\"line\">                handlePossibleCancellationInterrupt(s);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>并调用了c.call()方法,而mFuture初始化时传入了一个callable,也就是调用的这个callable的call方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public FutureTask(Callable&lt;V&gt; callable) &#123;</span><br><span class=\"line\">        if (callable == null)</span><br><span class=\"line\">            throw new NullPointerException();</span><br><span class=\"line\">        this.callable = callable;</span><br><span class=\"line\">        this.state = NEW;       // ensure visibility of callable</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>mFuture在初始化时传进去一个mWorker,也就是一个Callable</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123;</span><br><span class=\"line\">            public Result call() throws Exception &#123;</span><br><span class=\"line\">                mTaskInvoked.set(true);</span><br><span class=\"line\">                Result result = null;</span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class=\"line\">                    //noinspection unchecked</span><br><span class=\"line\">                    result = doInBackground(mParams);</span><br><span class=\"line\">                    Binder.flushPendingCommands();</span><br><span class=\"line\">                &#125; catch (Throwable tr) &#123;</span><br><span class=\"line\">                    mCancelled.set(true);</span><br><span class=\"line\">                    throw tr;</span><br><span class=\"line\">                &#125; finally &#123;</span><br><span class=\"line\">                    postResult(result);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                return result;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br></pre></td></tr></table></figure>\n\n<p>在这里执行了doInBackground(mParams),且是异步执行,在finally中调用了 postResult(result),publishProgress需要手动调用才会执行.</p>\n<p>postResult(result)方法是在异步调用,但方法里的实现使用Handler发送消息到主线程</p>\n<pre><code>private Result postResult(Result result) {\n    @SuppressWarnings(&quot;unchecked&quot;)\n    Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT,\n            new AsyncTaskResult&lt;Result&gt;(this, result));\n    message.sendToTarget();\n    return result;\n}</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static class InternalHandler extends Handler &#123;</span><br><span class=\"line\">        public InternalHandler(Looper looper) &#123;</span><br><span class=\"line\">            super(looper);</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n\n<pre><code>    @SuppressWarnings({&quot;unchecked&quot;, &quot;RawUseOfParameterizedType&quot;})\n    @Override\n    public void handleMessage(Message msg) {\n        AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj;\n        switch (msg.what) {\n            case MESSAGE_POST_RESULT:\n                // There is only one result\n                result.mTask.finish(result.mData[0]);\n                break;\n            case MESSAGE_POST_PROGRESS:\n                result.mTask.onProgressUpdate(result.mData);\n                break;\n        }\n    }\n}</code></pre><p>最终在主线程中回调了publishProgress和onPostExecute(result)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@WorkerThread</span><br><span class=\"line\">    protected final void publishProgress(Progress... values) &#123;</span><br><span class=\"line\">        if (!isCancelled()) &#123;</span><br><span class=\"line\">            getHandler().obtainMessage(MESSAGE_POST_PROGRESS,</span><br><span class=\"line\">                    new AsyncTaskResult&lt;Progress&gt;(this, values)).sendToTarget();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<pre><code>private void finish(Result result) {\n    if (isCancelled()) {\n        onCancelled(result);\n    } else {\n        onPostExecute(result);\n    }\n    mStatus = Status.FINISHED;\n}</code></pre>","site":{"data":{}},"excerpt":"<p>先看一下用法</p>\n<pre><code>AsyncTask&lt;Void, Void, Void&gt; asyncTask = new AsyncTask&lt;Void, Void, Void&gt;() {\n\n    @Override\n    protected Void doInBackground(Void... voids) {\n        return null;\n    }\n};\nasyncTask.execute();</code></pre><p>源码中这是一个抽象类,必须自己去实现,才能使用</p>","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public abstract class AsyncTask&lt;Params, Progress, Result&gt;</span><br></pre></td></tr></table></figure>\n\n<p>有三个参数,第一个是你要传什么东西异步使用,一般可能是网址,不需要传可以填void,第二个参数为执行进度,不需要也可以填void,第三个是返回数据,也可以填void.</p>\n<p>用asyncTask.execute()执行AsyncTask,括号中填的跟第一个参数对应. excute()方法调用了这个方法,还是在主线程中</p>\n<pre><code>@MainThread\npublic final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) {\n    return executeOnExecutor(sDefaultExecutor, params);\n}</code></pre><p>之后调用</p>\n<pre><code>@MainThread\npublic final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec,\n        Params... params) {\n    if (mStatus != Status.PENDING) {\n        switch (mStatus) {\n            case RUNNING:\n                throw new IllegalStateException(&quot;Cannot execute task:&quot;\n                        + &quot; the task is already running.&quot;);\n            case FINISHED:\n                throw new IllegalStateException(&quot;Cannot execute task:&quot;\n                        + &quot; the task has already been executed &quot;\n                        + &quot;(a task can be executed only once)&quot;);\n        }\n    }\n\n    mStatus = Status.RUNNING;\n\n    onPreExecute();\n\n    mWorker.mParams = params;\n    exec.execute(mFuture);\n\n    return this;\n}</code></pre><p>这个方法中判断了mStatus的状态,里面有两个异常抛出,可以看出一个任务只能执行一次. 而mStatus在初始化时置为了Status.PENDING,所以不会进入if (mStatus != Status.PENDING),会改变mStatus状态:mStatus = Status.RUNNING;</p>\n<p>private volatile Status mStatus = Status.PENDING;<br>接下来调用onPreExecute(),点进去看一下这个方法.</p>\n<pre><code>@MainThread\nprotected void onPreExecute() {\n}</code></pre><p>这方法是空实现,注解表示此时仍在主线程中,之后调用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">exec.execute(mFuture);</span><br><span class=\"line\">void execute(Runnable command);</span><br></pre></td></tr></table></figure>\n\n<p>exec是之前的sDefaultExecutor</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR;</span><br><span class=\"line\"></span><br><span class=\"line\">public static final Executor SERIAL_EXECUTOR = new SerialExecutor();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">private static class SerialExecutor implements Executor &#123;</span><br><span class=\"line\">        final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;();</span><br><span class=\"line\">        Runnable mActive;</span><br></pre></td></tr></table></figure>\n\n<pre><code>    public synchronized void execute(final Runnable r) {\n        mTasks.offer(new Runnable() {\n            public void run() {\n                try {\n                    r.run();\n                } finally {\n                    scheduleNext();\n                }\n            }\n        });\n        if (mActive == null) {\n            scheduleNext();\n        }\n    }\n\n    protected synchronized void scheduleNext() {\n        if ((mActive = mTasks.poll()) != null) {\n            THREAD_POOL_EXECUTOR.execute(mActive);\n        }\n    }\n}</code></pre><p>scheduleNext()在这个方法中,由线程池来执行任务</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protected synchronized void scheduleNext() &#123;</span><br><span class=\"line\">            if ((mActive = mTasks.poll()) != null) &#123;</span><br><span class=\"line\">                THREAD_POOL_EXECUTOR.execute(mActive);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\"></span><br><span class=\"line\">public E poll() &#123;</span><br><span class=\"line\">        return pollFirst();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p> 也就是会调出第一个任务来执行</p>\n<p>execute方法 需要一个Runnable,最终调用Runnable的run方法,也就是mFuture的run方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void run() &#123;</span><br><span class=\"line\">        if (state != NEW ||</span><br><span class=\"line\">            !U.compareAndSwapObject(this, RUNNER, null, Thread.currentThread()))</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            Callable&lt;V&gt; c = callable;</span><br><span class=\"line\">            if (c != null &amp;&amp; state == NEW) &#123;</span><br><span class=\"line\">                V result;</span><br><span class=\"line\">                boolean ran;</span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                    result = c.call();</span><br><span class=\"line\">                    ran = true;</span><br><span class=\"line\">                &#125; catch (Throwable ex) &#123;</span><br><span class=\"line\">                    result = null;</span><br><span class=\"line\">                    ran = false;</span><br><span class=\"line\">                    setException(ex);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                if (ran)</span><br><span class=\"line\">                    set(result);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; finally &#123;</span><br><span class=\"line\">            // runner must be non-null until state is settled to</span><br><span class=\"line\">            // prevent concurrent calls to run()</span><br><span class=\"line\">            runner = null;</span><br><span class=\"line\">            // state must be re-read after nulling runner to prevent</span><br><span class=\"line\">            // leaked interrupts</span><br><span class=\"line\">            int s = state;</span><br><span class=\"line\">            if (s &gt;= INTERRUPTING)</span><br><span class=\"line\">                handlePossibleCancellationInterrupt(s);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>并调用了c.call()方法,而mFuture初始化时传入了一个callable,也就是调用的这个callable的call方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public FutureTask(Callable&lt;V&gt; callable) &#123;</span><br><span class=\"line\">        if (callable == null)</span><br><span class=\"line\">            throw new NullPointerException();</span><br><span class=\"line\">        this.callable = callable;</span><br><span class=\"line\">        this.state = NEW;       // ensure visibility of callable</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>mFuture在初始化时传进去一个mWorker,也就是一个Callable</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123;</span><br><span class=\"line\">            public Result call() throws Exception &#123;</span><br><span class=\"line\">                mTaskInvoked.set(true);</span><br><span class=\"line\">                Result result = null;</span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class=\"line\">                    //noinspection unchecked</span><br><span class=\"line\">                    result = doInBackground(mParams);</span><br><span class=\"line\">                    Binder.flushPendingCommands();</span><br><span class=\"line\">                &#125; catch (Throwable tr) &#123;</span><br><span class=\"line\">                    mCancelled.set(true);</span><br><span class=\"line\">                    throw tr;</span><br><span class=\"line\">                &#125; finally &#123;</span><br><span class=\"line\">                    postResult(result);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                return result;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br></pre></td></tr></table></figure>\n\n<p>在这里执行了doInBackground(mParams),且是异步执行,在finally中调用了 postResult(result),publishProgress需要手动调用才会执行.</p>\n<p>postResult(result)方法是在异步调用,但方法里的实现使用Handler发送消息到主线程</p>\n<pre><code>private Result postResult(Result result) {\n    @SuppressWarnings(&quot;unchecked&quot;)\n    Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT,\n            new AsyncTaskResult&lt;Result&gt;(this, result));\n    message.sendToTarget();\n    return result;\n}</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private static class InternalHandler extends Handler &#123;</span><br><span class=\"line\">        public InternalHandler(Looper looper) &#123;</span><br><span class=\"line\">            super(looper);</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n\n<pre><code>    @SuppressWarnings({&quot;unchecked&quot;, &quot;RawUseOfParameterizedType&quot;})\n    @Override\n    public void handleMessage(Message msg) {\n        AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj;\n        switch (msg.what) {\n            case MESSAGE_POST_RESULT:\n                // There is only one result\n                result.mTask.finish(result.mData[0]);\n                break;\n            case MESSAGE_POST_PROGRESS:\n                result.mTask.onProgressUpdate(result.mData);\n                break;\n        }\n    }\n}</code></pre><p>最终在主线程中回调了publishProgress和onPostExecute(result)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@WorkerThread</span><br><span class=\"line\">    protected final void publishProgress(Progress... values) &#123;</span><br><span class=\"line\">        if (!isCancelled()) &#123;</span><br><span class=\"line\">            getHandler().obtainMessage(MESSAGE_POST_PROGRESS,</span><br><span class=\"line\">                    new AsyncTaskResult&lt;Progress&gt;(this, values)).sendToTarget();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<pre><code>private void finish(Result result) {\n    if (isCancelled()) {\n        onCancelled(result);\n    } else {\n        onPostExecute(result);\n    }\n    mStatus = Status.FINISHED;\n}</code></pre>"},{"title":"Hello World","toc":true,"_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n<!-- more -->\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n\n\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\ntoc: true\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n<!-- more -->\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n\n\n","slug":"hello-world","published":1,"date":"2019-07-11T03:13:37.000Z","updated":"2019-07-19T05:46:55.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck03xfcaj00074frruf752dzy","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<a id=\"more\"></a>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>","more":"<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>"},{"layout":"post","title":"关于面试(一)","date":"2019-07-18T16:00:00.000Z","body":["article","comments"],"toc":true,"_content":"## 优化篇\n\n### 内存泄漏\n\n1. 内部类隐性的持有外部类的引用导致内存泄漏:常见的如使用handler时,直接new创建对象,当页面关闭时,如果handler还在运行时会持有activity的引用,导致activity得不到释放,从而引起内存泄漏。\n    解决方法:使用静态内部类,然后用弱引用持有外部类的引用\n    <!-- more -->\n2. 静态变量引起的内存泄漏:静态变量的生命周期和应用的生命周期一样长,如果用静态变量引用了某个activity的实例会导致activity得不到释放,\n    解决方法:将activity的引用改为application的引用\n3. 资源对象未关闭:对于使用了BraodcastReceiver，ContentObserver，File，Cursor，Stream，Bitmap等资源的代码，应该在Activity销毁时及时关闭或者注销，否则这些资源将不会被回收，造成内存泄漏\n4. 集合中对象没有清理造成的内存泄漏,在实际开发过程中难免会有把对象添加到集合容器（比如 ArrayList）中的需求，如果在一个对象使用结束之后未将该对象从该容器中移除掉，就会造成该对象不能被正确回收，从而造成内存泄漏，解决办法当然就是在使用完之后将该对象从容器中移除。\n5. webview引起的内存泄漏主要是因为org.chromium.android_webview.AwContents 类中注册了component callbacks，但是未正常反注册而导致的。让onDetachedFromWindow先走，在主动调用destroy()之前，把webview从它的parent上面移除掉(Basewebfragment onDestroy())\n\n### 内存优化\n\n1. 降低运行时内存:![](https://coolyun1.oss-cn-shenzhen.aliyuncs.com/20190719141209.png)\n    降低运行时内存可以分为两部分:\n    *   减小apk体积:去除无用的代码和资源,尽量复用资源,对图片资源进行压缩\n    *   Bitmap优化:  统一的图片加载器:图片加载器默认会对图片进行缓存,按view的实际大小进行加载.inSampleSize进行缩放比例,选择合适的bitmap格式(ARGB_8888/RGB_565/ARGB——4444/ALPHA_8)\n2. 代码优化:考虑使用ArrayMap/SpareseArray　而不是传统的HashMap等数据结构,Android系统未移动系统设计的容器ArrayMap更加高效,占用内存更少,因为HashMap需要一个额外的实例对象来记录Mapping的操作.而SparesArray高效的避免了key和value的自动装箱,而且避免了装箱后的拆箱\n3. 在onDraw这种频繁调用的方法要避免对象的创建操作,它会迅速增加内存的使用,引起频繁gc,甚至内存抖动.\n4. SoftReference(软引用)、WeakReference(弱引用)、PhantomReference(虚引用):\n    \n    ``` \nSoftReference：如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。\nWeakReference：与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。\nPhantomReference：虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之 关联的引用队列中。\n    ```\n5. 考虑第三方库的大小，如果会和现有的代码或其他库的代码重复，考虑不要真个引入而是把库的代码精简之后再引入。\n\n### 流畅优化\n1. 界面绘制:主要原因是绘制的层级深,页面复杂,刷新不合理\n    *   布局服用,使用标签重用layout;提高显示速度,使用延迟view加载;减少层级,使用标签替换父级布局;wrap_content,会增加measure计算成本;删除空间中无用属性.   \n2. 数据处理:导致这种卡顿场景的原因在于数据处理量太大,一般分三种情况:一是数据处理在UI线程,二是数据处理占用的cpu高,导致主线程拿不到时间片,三是内存增加导致GC频繁,从而引起卡顿\n\n\n\n\n\n### 参考\n[Android内存泄漏的检测与分析以及解决方案小结](https://www.jianshu.com/p/bdc88955961c)\n[谈一谈Android内存优化那些事（二）Android常用的内存优化方法](https://www.jianshu.com/p/8ee81d5ff770)\n\n\n\n\n\n","source":"_posts/关于面试(一).md","raw":"---\nlayout: post\ntitle: 关于面试(一)\ndate: 2019.7.19\nbody: [article,  comments]\ntoc: true\ntag: [Android,面试]\ncategories: [Android]\n---\n## 优化篇\n\n### 内存泄漏\n\n1. 内部类隐性的持有外部类的引用导致内存泄漏:常见的如使用handler时,直接new创建对象,当页面关闭时,如果handler还在运行时会持有activity的引用,导致activity得不到释放,从而引起内存泄漏。\n    解决方法:使用静态内部类,然后用弱引用持有外部类的引用\n    <!-- more -->\n2. 静态变量引起的内存泄漏:静态变量的生命周期和应用的生命周期一样长,如果用静态变量引用了某个activity的实例会导致activity得不到释放,\n    解决方法:将activity的引用改为application的引用\n3. 资源对象未关闭:对于使用了BraodcastReceiver，ContentObserver，File，Cursor，Stream，Bitmap等资源的代码，应该在Activity销毁时及时关闭或者注销，否则这些资源将不会被回收，造成内存泄漏\n4. 集合中对象没有清理造成的内存泄漏,在实际开发过程中难免会有把对象添加到集合容器（比如 ArrayList）中的需求，如果在一个对象使用结束之后未将该对象从该容器中移除掉，就会造成该对象不能被正确回收，从而造成内存泄漏，解决办法当然就是在使用完之后将该对象从容器中移除。\n5. webview引起的内存泄漏主要是因为org.chromium.android_webview.AwContents 类中注册了component callbacks，但是未正常反注册而导致的。让onDetachedFromWindow先走，在主动调用destroy()之前，把webview从它的parent上面移除掉(Basewebfragment onDestroy())\n\n### 内存优化\n\n1. 降低运行时内存:![](https://coolyun1.oss-cn-shenzhen.aliyuncs.com/20190719141209.png)\n    降低运行时内存可以分为两部分:\n    *   减小apk体积:去除无用的代码和资源,尽量复用资源,对图片资源进行压缩\n    *   Bitmap优化:  统一的图片加载器:图片加载器默认会对图片进行缓存,按view的实际大小进行加载.inSampleSize进行缩放比例,选择合适的bitmap格式(ARGB_8888/RGB_565/ARGB——4444/ALPHA_8)\n2. 代码优化:考虑使用ArrayMap/SpareseArray　而不是传统的HashMap等数据结构,Android系统未移动系统设计的容器ArrayMap更加高效,占用内存更少,因为HashMap需要一个额外的实例对象来记录Mapping的操作.而SparesArray高效的避免了key和value的自动装箱,而且避免了装箱后的拆箱\n3. 在onDraw这种频繁调用的方法要避免对象的创建操作,它会迅速增加内存的使用,引起频繁gc,甚至内存抖动.\n4. SoftReference(软引用)、WeakReference(弱引用)、PhantomReference(虚引用):\n    \n    ``` \nSoftReference：如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。\nWeakReference：与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。\nPhantomReference：虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之 关联的引用队列中。\n    ```\n5. 考虑第三方库的大小，如果会和现有的代码或其他库的代码重复，考虑不要真个引入而是把库的代码精简之后再引入。\n\n### 流畅优化\n1. 界面绘制:主要原因是绘制的层级深,页面复杂,刷新不合理\n    *   布局服用,使用标签重用layout;提高显示速度,使用延迟view加载;减少层级,使用标签替换父级布局;wrap_content,会增加measure计算成本;删除空间中无用属性.   \n2. 数据处理:导致这种卡顿场景的原因在于数据处理量太大,一般分三种情况:一是数据处理在UI线程,二是数据处理占用的cpu高,导致主线程拿不到时间片,三是内存增加导致GC频繁,从而引起卡顿\n\n\n\n\n\n### 参考\n[Android内存泄漏的检测与分析以及解决方案小结](https://www.jianshu.com/p/bdc88955961c)\n[谈一谈Android内存优化那些事（二）Android常用的内存优化方法](https://www.jianshu.com/p/8ee81d5ff770)\n\n\n\n\n\n","slug":"关于面试(一)","published":1,"updated":"2019-07-19T06:12:28.000Z","comments":1,"photos":[],"link":"","_id":"ck03xfcal00084frr839cv9sb","content":"<h2 id=\"优化篇\"><a href=\"#优化篇\" class=\"headerlink\" title=\"优化篇\"></a>优化篇</h2><h3 id=\"内存泄漏\"><a href=\"#内存泄漏\" class=\"headerlink\" title=\"内存泄漏\"></a>内存泄漏</h3><ol>\n<li>内部类隐性的持有外部类的引用导致内存泄漏:常见的如使用handler时,直接new创建对象,当页面关闭时,如果handler还在运行时会持有activity的引用,导致activity得不到释放,从而引起内存泄漏。<br> 解决方法:使用静态内部类,然后用弱引用持有外部类的引用 <a id=\"more\"></a></li>\n<li>静态变量引起的内存泄漏:静态变量的生命周期和应用的生命周期一样长,如果用静态变量引用了某个activity的实例会导致activity得不到释放,<br> 解决方法:将activity的引用改为application的引用</li>\n<li>资源对象未关闭:对于使用了BraodcastReceiver，ContentObserver，File，Cursor，Stream，Bitmap等资源的代码，应该在Activity销毁时及时关闭或者注销，否则这些资源将不会被回收，造成内存泄漏</li>\n<li>集合中对象没有清理造成的内存泄漏,在实际开发过程中难免会有把对象添加到集合容器（比如 ArrayList）中的需求，如果在一个对象使用结束之后未将该对象从该容器中移除掉，就会造成该对象不能被正确回收，从而造成内存泄漏，解决办法当然就是在使用完之后将该对象从容器中移除。</li>\n<li>webview引起的内存泄漏主要是因为org.chromium.android_webview.AwContents 类中注册了component callbacks，但是未正常反注册而导致的。让onDetachedFromWindow先走，在主动调用destroy()之前，把webview从它的parent上面移除掉(Basewebfragment onDestroy())</li>\n</ol>\n<h3 id=\"内存优化\"><a href=\"#内存优化\" class=\"headerlink\" title=\"内存优化\"></a>内存优化</h3><ol>\n<li><p>降低运行时内存:<img src=\"https://coolyun1.oss-cn-shenzhen.aliyuncs.com/20190719141209.png\" alt><br> 降低运行时内存可以分为两部分:</p>\n<ul>\n<li>减小apk体积:去除无用的代码和资源,尽量复用资源,对图片资源进行压缩</li>\n<li>Bitmap优化:  统一的图片加载器:图片加载器默认会对图片进行缓存,按view的实际大小进行加载.inSampleSize进行缩放比例,选择合适的bitmap格式(ARGB_8888/RGB_565/ARGB——4444/ALPHA_8)</li>\n</ul>\n</li>\n<li><p>代码优化:考虑使用ArrayMap/SpareseArray　而不是传统的HashMap等数据结构,Android系统未移动系统设计的容器ArrayMap更加高效,占用内存更少,因为HashMap需要一个额外的实例对象来记录Mapping的操作.而SparesArray高效的避免了key和value的自动装箱,而且避免了装箱后的拆箱</p>\n</li>\n<li><p>在onDraw这种频繁调用的方法要避免对象的创建操作,它会迅速增加内存的使用,引起频繁gc,甚至内存抖动.</p>\n</li>\n<li><p>SoftReference(软引用)、WeakReference(弱引用)、PhantomReference(虚引用):</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SoftReference：如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。</span><br><span class=\"line\">WeakReference：与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。</span><br><span class=\"line\">PhantomReference：虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之 关联的引用队列中。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>考虑第三方库的大小，如果会和现有的代码或其他库的代码重复，考虑不要真个引入而是把库的代码精简之后再引入。</p>\n</li>\n</ol>\n<h3 id=\"流畅优化\"><a href=\"#流畅优化\" class=\"headerlink\" title=\"流畅优化\"></a>流畅优化</h3><ol>\n<li>界面绘制:主要原因是绘制的层级深,页面复杂,刷新不合理<ul>\n<li>布局服用,使用标签重用layout;提高显示速度,使用延迟view加载;减少层级,使用标签替换父级布局;wrap_content,会增加measure计算成本;删除空间中无用属性.   </li>\n</ul>\n</li>\n<li>数据处理:导致这种卡顿场景的原因在于数据处理量太大,一般分三种情况:一是数据处理在UI线程,二是数据处理占用的cpu高,导致主线程拿不到时间片,三是内存增加导致GC频繁,从而引起卡顿</li>\n</ol>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p><a href=\"https://www.jianshu.com/p/bdc88955961c\" target=\"_blank\" rel=\"noopener\">Android内存泄漏的检测与分析以及解决方案小结</a><br><a href=\"https://www.jianshu.com/p/8ee81d5ff770\" target=\"_blank\" rel=\"noopener\">谈一谈Android内存优化那些事（二）Android常用的内存优化方法</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"优化篇\"><a href=\"#优化篇\" class=\"headerlink\" title=\"优化篇\"></a>优化篇</h2><h3 id=\"内存泄漏\"><a href=\"#内存泄漏\" class=\"headerlink\" title=\"内存泄漏\"></a>内存泄漏</h3><ol>\n<li>内部类隐性的持有外部类的引用导致内存泄漏:常见的如使用handler时,直接new创建对象,当页面关闭时,如果handler还在运行时会持有activity的引用,导致activity得不到释放,从而引起内存泄漏。<br> 解决方法:使用静态内部类,然后用弱引用持有外部类的引用","more":"</li>\n<li>静态变量引起的内存泄漏:静态变量的生命周期和应用的生命周期一样长,如果用静态变量引用了某个activity的实例会导致activity得不到释放,<br> 解决方法:将activity的引用改为application的引用</li>\n<li>资源对象未关闭:对于使用了BraodcastReceiver，ContentObserver，File，Cursor，Stream，Bitmap等资源的代码，应该在Activity销毁时及时关闭或者注销，否则这些资源将不会被回收，造成内存泄漏</li>\n<li>集合中对象没有清理造成的内存泄漏,在实际开发过程中难免会有把对象添加到集合容器（比如 ArrayList）中的需求，如果在一个对象使用结束之后未将该对象从该容器中移除掉，就会造成该对象不能被正确回收，从而造成内存泄漏，解决办法当然就是在使用完之后将该对象从容器中移除。</li>\n<li>webview引起的内存泄漏主要是因为org.chromium.android_webview.AwContents 类中注册了component callbacks，但是未正常反注册而导致的。让onDetachedFromWindow先走，在主动调用destroy()之前，把webview从它的parent上面移除掉(Basewebfragment onDestroy())</li>\n</ol>\n<h3 id=\"内存优化\"><a href=\"#内存优化\" class=\"headerlink\" title=\"内存优化\"></a>内存优化</h3><ol>\n<li><p>降低运行时内存:<img src=\"https://coolyun1.oss-cn-shenzhen.aliyuncs.com/20190719141209.png\" alt><br> 降低运行时内存可以分为两部分:</p>\n<ul>\n<li>减小apk体积:去除无用的代码和资源,尽量复用资源,对图片资源进行压缩</li>\n<li>Bitmap优化:  统一的图片加载器:图片加载器默认会对图片进行缓存,按view的实际大小进行加载.inSampleSize进行缩放比例,选择合适的bitmap格式(ARGB_8888/RGB_565/ARGB——4444/ALPHA_8)</li>\n</ul>\n</li>\n<li><p>代码优化:考虑使用ArrayMap/SpareseArray　而不是传统的HashMap等数据结构,Android系统未移动系统设计的容器ArrayMap更加高效,占用内存更少,因为HashMap需要一个额外的实例对象来记录Mapping的操作.而SparesArray高效的避免了key和value的自动装箱,而且避免了装箱后的拆箱</p>\n</li>\n<li><p>在onDraw这种频繁调用的方法要避免对象的创建操作,它会迅速增加内存的使用,引起频繁gc,甚至内存抖动.</p>\n</li>\n<li><p>SoftReference(软引用)、WeakReference(弱引用)、PhantomReference(虚引用):</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SoftReference：如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。</span><br><span class=\"line\">WeakReference：与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。</span><br><span class=\"line\">PhantomReference：虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之 关联的引用队列中。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>考虑第三方库的大小，如果会和现有的代码或其他库的代码重复，考虑不要真个引入而是把库的代码精简之后再引入。</p>\n</li>\n</ol>\n<h3 id=\"流畅优化\"><a href=\"#流畅优化\" class=\"headerlink\" title=\"流畅优化\"></a>流畅优化</h3><ol>\n<li>界面绘制:主要原因是绘制的层级深,页面复杂,刷新不合理<ul>\n<li>布局服用,使用标签重用layout;提高显示速度,使用延迟view加载;减少层级,使用标签替换父级布局;wrap_content,会增加measure计算成本;删除空间中无用属性.   </li>\n</ul>\n</li>\n<li>数据处理:导致这种卡顿场景的原因在于数据处理量太大,一般分三种情况:一是数据处理在UI线程,二是数据处理占用的cpu高,导致主线程拿不到时间片,三是内存增加导致GC频繁,从而引起卡顿</li>\n</ol>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p><a href=\"https://www.jianshu.com/p/bdc88955961c\" target=\"_blank\" rel=\"noopener\">Android内存泄漏的检测与分析以及解决方案小结</a><br><a href=\"https://www.jianshu.com/p/8ee81d5ff770\" target=\"_blank\" rel=\"noopener\">谈一谈Android内存优化那些事（二）Android常用的内存优化方法</a></p>"},{"layout":"post","title":"关于面试(二)","date":"2019-07-18T16:00:00.000Z","body":["article","comments"],"sidebar":false,"_content":"#### view的绘制流程\nAndroid的UI管理系统层级关系\n![](https://coolyun1.oss-cn-shenzhen.aliyuncs.com/20190719141337.png)\n    View的绘制过程是从ViewRoot的performTraversals方法开始的，在其内部依次调用View的performMeasure,performLayout,performDraw三个方法。这三个方法分别完成顶级View的measure,layout,draw过程。其中，performMeasure中会调用measure方法，而在measure方法中又会调用onMeausre()方法，然后在onMeaure方法中会对所有的子元素进行measure过程，这时measure流程就从父容器传递到了子元素中，子元素会继续重复父容器的measure过程，如此反复即完成了整个View树结构的遍历，最终 完成View的测量过程。\n<!-- more -->\n    同理，performLayout和performDraw方法的传递流程和performMeasure类似，但不同的是，performDraw的传递是在draw方法中通过dispatchDraw方法来下发的，不过本质上原理还是一样的。下面给出一张流程图方便大家更好的理解：\n![](https://coolyun1.oss-cn-shenzhen.aliyuncs.com/20190719141403.png)\n只看一下主要几个方法:\n1. performMeasure\n\n```\nprivate void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) {\n        Trace.traceBegin(Trace.TRACE_TAG_VIEW, \"measure\");\n        try {\n            mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);\n        } finally {\n            Trace.traceEnd(Trace.TRACE_TAG_VIEW);\n        }\n    }\n```\n\n```\npublic final void measure(int widthMeasureSpec, int heightMeasureSpec) {\n         // 调用onMeasure()\n         onMeasure(widthMeasureSpec, heightMeasureSpec); \n    }\n```\n\n```\n@Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        if (mOrientation == VERTICAL) {\n            // 我们以垂直为例\n            measureVertical(widthMeasureSpec, heightMeasureSpec);\n        } else {\n            measureHorizontal(widthMeasureSpec, heightMeasureSpec);\n        }\n    }\n```\n\n```\nvoid measureVertical(int widthMeasureSpec, int heightMeasureSpec) {\n        // See how tall everyone is. Also remember max width.\n        for (int i = 0; i < count; ++i) {\n            final View child = getVirtualChildAt(i);\n            // 测量子孩子\n            measureChildBeforeLayout(child, i, widthMeasureSpec, 0,\n                        heightMeasureSpec, usedHeight);\n\n            final int childHeight = child.getMeasuredHeight();\n\n            final int totalLength = mTotalLength;\n            // 高度是子View的高度不断的叠加\n            mTotalLength = Math.max(totalLength, totalLength + childHeight + lp.topMargin +\n                       lp.bottomMargin + getNextLocationOffset(child));\n        }\n        int heightSize = mTotalLength;\n        // Check against our minimum height\n        heightSize = Math.max(heightSize, getSuggestedMinimumHeight());\n        \n        // Reconcile our calculated size with the heightMeasureSpec\n        int heightSizeAndState = resolveSizeAndState(heightSize, heightMeasureSpec, 0);\n        // 设置宽高\n        setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState),\n                heightSizeAndState);\n    }\n```\nViewGroup在调用onMeasure()方法的时候,会不断的循环测量子view.\n\n```\nvoid measureChildBeforeLayout(View child, int childIndex,\n            int widthMeasureSpec, int totalWidth, int heightMeasureSpec,\n            int totalHeight) {\n        measureChildWithMargins(child, widthMeasureSpec, totalWidth,\n                heightMeasureSpec, totalHeight);\n    }\n```\n\n```\nprotected void measureChildWithMargins(View child,\n            int parentWidthMeasureSpec, int widthUsed,\n            int parentHeightMeasureSpec, int heightUsed) {\n        final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();\n        //  getChildMeasureSpec 这个方法非常关键\n        final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,\n                mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin\n                        + widthUsed, lp.width);\n        final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,\n                mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin\n                        + heightUsed, lp.height);\n\n        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);\n    }\n```\n三种测量方式:\n![](https://coolyun1.oss-cn-shenzhen.aliyuncs.com/20190719141441.png)\n\n```\npublic static int getChildMeasureSpec(int spec, int padding, int childDimension) {\n        //获取当前Parent View的Mode和Size\n        int specMode = MeasureSpec.getMode(spec);\n        int specSize = MeasureSpec.getSize(spec);\n        //获取Parent size与padding差值（也就是Parent剩余大小），若差值小于0直接返回0\n        int size = Math.max(0, specSize - padding);\n        //定义返回值存储变量\n        int resultSize = 0;\n        int resultMode = 0;\n        //依据当前Parent的Mode进行switch分支逻辑\n        switch (specMode) {\n        // Parent has imposed an exact size on us\n        case MeasureSpec.EXACTLY:\n            if (childDimension >= 0) {\n                //如果child的layout_w和h属性在xml或者java中给予具体大于等于0的数值\n                //设置child的size为真实layout_w和h属性值，mode为EXACTLY\n                resultSize = childDimension;\n                resultMode = MeasureSpec.EXACTLY;\n            } else if (childDimension == LayoutParams.MATCH_PARENT) {\n                // Child wants to be our size. So be it.\n                //如果child的layout_wOrh属性在xml或者java中给予MATCH_PARENT\n                //设置child的size为size，mode为EXACTLY\n                resultSize = size;\n                resultMode = MeasureSpec.EXACTLY;\n            } else if (childDimension == LayoutParams.WRAP_CONTENT) {\n                // Child wants to determine its own size. It can't be\n                // bigger than us.\n                //如果child的layout_wOrh属性在xml或者java中给予WRAP_CONTENT\n                //设置child的size为size，mode为AT_MOST\n                resultSize = size;\n                resultMode = MeasureSpec.AT_MOST;\n            }\n            break;\n\n        // Parent has imposed a maximum size on us\n        case MeasureSpec.AT_MOST:\n            if (childDimension >= 0) {\n                // ......\n            } else if (childDimension == LayoutParams.MATCH_PARENT) {\n                // Child wants to be our size, but our size is not fixed.\n                // Constrain child to not be bigger than us.\n                // 如果父 View 是 AT_MOST 就算子 View 是 MATCH_PARENT，\n                // 其实子View获得的测量模式还是AT_MOST\n                resultSize = size;\n                resultMode = MeasureSpec.AT_MOST;\n            } else if (childDimension == LayoutParams.WRAP_CONTENT) {\n                // Child wants to determine its own size. It can't be\n                // bigger than us.\n                resultSize = size;\n                resultMode = MeasureSpec.AT_MOST;\n            }\n            break;\n\n            // ......\n        }\n        //noinspection ResourceType\n        return MeasureSpec.makeMeasureSpec(resultSize, resultMode);\n    }\n```\nView的绘制流程第一步是onMeasure()，该方法用来测量和指定布局到底占多大的宽高，因为控件的宽高是由父布局和本身来决定的，所以测量是不断的往内走，而最终确定宽高是由内不断的往外走，是递归的方式。\n2. performLayout\n\n```\nprivate void performLayout(WindowManager.LayoutParams lp, int desiredWindowWidth,\n            int desiredWindowHeight) {\n        final View host = mView;\n        // 调用layout()方法\n        host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight());\n    }\n\n    public void layout(int l, int t, int r, int b) {\n        onLayout(changed, l, t, r, b);\n    }\n```\n\n```\n@Override\n    protected void onLayout(boolean changed, int l, int t, int r, int b) {\n        if (mOrientation == VERTICAL) {\n            // 我们以垂直为例\n            layoutVertical(l, t, r, b);\n        } else {\n            layoutHorizontal(l, t, r, b);\n        }\n    }\n```\n\n```\nvoid layoutVertical(int left, int top, int right, int bottom) {\n        final int paddingLeft = mPaddingLeft;\n\n        int childTop;\n        int childLeft;\n\n        // Where right end of child should go\n        //计算父窗口推荐的子View宽度\n        final int width = right - left;\n        //计算父窗口推荐的子View右侧位置\n        int childRight = width - mPaddingRight;\n\n        // Space available for child\n        //child可使用空间大小\n        int childSpace = width - paddingLeft - mPaddingRight;\n        //通过ViewGroup的getChildCount方法获取ViewGroup的子View个数\n        final int count = getVirtualChildCount();\n        //获取Gravity属性设置\n        final int majorGravity = mGravity & Gravity.VERTICAL_GRAVITY_MASK;\n        final int minorGravity = mGravity & Gravity.RELATIVE_HORIZONTAL_GRAVITY_MASK;\n        //依据majorGravity计算childTop的位置值\n        switch (majorGravity) {\n           case Gravity.BOTTOM:\n               // mTotalLength contains the padding already\n               childTop = mPaddingTop + bottom - top - mTotalLength;\n               break;\n\n               // mTotalLength contains the padding already\n           case Gravity.CENTER_VERTICAL:\n               childTop = mPaddingTop + (bottom - top - mTotalLength) / 2;\n               break;\n\n           case Gravity.TOP:\n           default:\n               childTop = mPaddingTop;\n               break;\n        }\n        //重点！！！开始遍历\n        for (int i = 0; i < count; i++) {\n            final View child = getVirtualChildAt(i);\n            if (child == null) {\n                childTop += measureNullChild(i);\n            } else if (child.getVisibility() != GONE) {\n                //LinearLayout中其子视图显示的宽和高由measure过程来决定的，因此measure过程的意义就是为layout过程提供视图显示范围的参考值\n                final int childWidth = child.getMeasuredWidth();\n                final int childHeight = child.getMeasuredHeight();\n                //获取子View的LayoutParams\n                final LinearLayout.LayoutParams lp =\n                        (LinearLayout.LayoutParams) child.getLayoutParams();\n\n                int gravity = lp.gravity;\n                if (gravity < 0) {\n                    gravity = minorGravity;\n                }\n                final int layoutDirection = getLayoutDirection();\n                final int absoluteGravity = Gravity.getAbsoluteGravity(gravity, layoutDirection);\n                //依据不同的absoluteGravity计算childLeft位置\n                switch (absoluteGravity & Gravity.HORIZONTAL_GRAVITY_MASK) {\n                    case Gravity.CENTER_HORIZONTAL:\n                        childLeft = paddingLeft + ((childSpace - childWidth) / 2)\n                                + lp.leftMargin - lp.rightMargin;\n                        break;\n\n                    case Gravity.RIGHT:\n                        childLeft = childRight - childWidth - lp.rightMargin;\n                        break;\n\n                    case Gravity.LEFT:\n                    default:\n                        childLeft = paddingLeft + lp.leftMargin;\n                        break;\n                }\n\n                if (hasDividerBeforeChildAt(i)) {\n                    childTop += mDividerHeight;\n                }\n\n                childTop += lp.topMargin;\n                //通过垂直排列计算调运child的layout设置child的位置\n                setChildFrame(child, childLeft, childTop + getLocationOffset(child),\n                        childWidth, childHeight);\n                childTop += childHeight + lp.bottomMargin + getNextLocationOffset(child);\n\n                i += getChildrenSkipCount(child, i);\n            }\n        }\n    }\n```\n从上面分析可以看出layout也是从顶层父View向子View的递归调用view.layout方法的过程，即父View根据第一步performMeasure，来获取子View所的布局大小和布局参数，将子View放在合适的位置上，不过这个方法没有再往外走，只是不断的往里面走。\n3. performDraw\n\n```\nprivate void performDraw() {\n        try {\n            draw(fullRedrawNeeded);\n        } finally {\n            mIsDrawing = false;\n            Trace.traceEnd(Trace.TRACE_TAG_VIEW);\n        }\n    }\n\n    private void draw(boolean fullRedrawNeeded) {\n        Surface surface = mSurface;\n        if (!surface.isValid()) {\n            return;\n        }\n        \n        if (!drawSoftware(surface, mAttachInfo, xOffset, yOffset, scalingRequired, dirty)) {\n            return;\n        }\n    }\n\n    private boolean drawSoftware(Surface surface, AttachInfo attachInfo, int xoff, int yoff,\n            boolean scalingRequired, Rect dirty) {\n        // Draw with software renderer.\n        final Canvas canvas;\n        final int left = dirty.left;\n        final int top = dirty.top;\n        final int right = dirty.right;\n        final int bottom = dirty.bottom;\n        canvas = mSurface.lockCanvas(dirty);\n        // ... ...\n        mView.draw(canvas);\n    }\n```\n#### 事件分发\n1. 事件类型(down,up,move,cancel),从手指借出屏幕到手指离开屏幕为一组事件\n![](https://coolyun1.oss-cn-shenzhen.aliyuncs.com/20190719141523.png)\n2. 事件分发的本质就是将点击事件传递到某个具体的view&处理的整个过程.\n3. 事件在Activity,ViewGroup,View中传递\n4. 事件分发由哪些方法协作完成\n![](https://coolyun1.oss-cn-shenzhen.aliyuncs.com/20190719141541.png)\n5. activity的事件分发:\n![](https://coolyun1.oss-cn-shenzhen.aliyuncs.com/20190719141600.png)\n![](https://coolyun1.oss-cn-shenzhen.aliyuncs.com/20190719141630.png)\n6. ViewGroup的事件分发:\n![](https://coolyun1.oss-cn-shenzhen.aliyuncs.com/20190719141645.png)\n7. View的事件分发:\n![](https://coolyun1.oss-cn-shenzhen.aliyuncs.com/20190719141703.png)\n![](https://coolyun1.oss-cn-shenzhen.aliyuncs.com/20190719141725.png)\n8. 总结\n![](https://coolyun1.oss-cn-shenzhen.aliyuncs.com/20190719141805.png)\n\n#### 测试\n从Activity到ViewGroup到View. Activity类中添加一下代码\n\n```\n@Override\n    public boolean onTouchEvent(MotionEvent event) {\n        Log.e(\"gao\", \"onTouchEvent: \"+this.getClass().getName());\n        return super.onTouchEvent(event);\n    }\n\n    @Override\n    public void onClick(View v) {\n        Log.e(\"gao\", \"onClick: \"+this.getClass().getName());\n    }\n\n    @Override\n    public boolean dispatchTouchEvent(MotionEvent ev) {\n        Log.e(\"gao\", \"dispatchTouchEvent: \"+this.getClass().getName());\n        return super.dispatchTouchEvent(ev);\n    }\n\n```\n ViewGroup中添加以下代码:\n\n \n```\n@Override\n    public boolean dispatchTouchEvent(MotionEvent ev) {\n        Log.e(\"gao\", \"dispatchTouchEvent: \"+this.getClass().getName());\n        return super.dispatchTouchEvent(ev);\n    }\n\n    @Override\n    public boolean onInterceptTouchEvent(MotionEvent ev) {\n        Log.e(\"gao\", \"onInterceptTouchEvent: \"+this.getClass().getName());\n        return super.onInterceptTouchEvent(ev);\n    }\n\n    @Override\n    public boolean onTouchEvent(MotionEvent event) {\n        Log.e(\"gao\", \"onTouchEvent: \"+this.getClass().getName());\n        return super.onTouchEvent(event);\n    }\n\n```\nView中添加以下代码:\n\n```\n@Override\n    public boolean onTouchEvent(MotionEvent event) {\n        Log.e(\"gao\", \"onTouchEvent: \"+this.getClass().getName());\n        return super.onTouchEvent(event);\n    }\n\n    @Override\n    public boolean dispatchTouchEvent(MotionEvent event) {\n        Log.e(\"gao\", \"dispatchTouchEvent: \"+this.getClass().getName());\n        return super.dispatchTouchEvent(event);\n    }\n\n```\n\n  默认情况下调用顺序:\n  \n```\n04-17 08:03:09.766 2887-2887/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n04-17 08:03:09.767 2887-2887/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 08:03:09.767 2887-2887/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 08:03:09.767 2887-2887/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn\n04-17 08:03:09.767 2887-2887/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn\n04-17 08:03:09.786 2887-2887/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 08:03:09.786 2887-2887/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n04-17 08:03:09.889 2887-2887/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n04-17 08:03:09.889 2887-2887/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n```\n\nview中touchEvent改为true\n\n```\n04-17 08:06:14.757 2992-2992/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n04-17 08:06:14.757 2992-2992/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 08:06:14.757 2992-2992/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 08:06:14.757 2992-2992/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn\n04-17 08:06:14.757 2992-2992/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn\n04-17 08:06:14.757 2992-2992/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n04-17 08:06:14.757 2992-2992/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 08:06:14.757 2992-2992/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 08:06:14.757 2992-2992/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn\n04-17 08:06:14.757 2992-2992/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn\n\n```\n\n事件传到View后不再往外传,因为已经被消费了 方法都调用了两遍是因为接收了down事件之后,up事件也传过来接收了\n\nview中touchEvent改为false\n\n```\n04-17 08:23:47.369 3622-3622/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n04-17 08:23:47.370 3622-3622/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 08:23:47.370 3622-3622/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 08:23:47.370 3622-3622/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn\n04-17 08:23:47.370 3622-3622/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn\n04-17 08:23:47.370 3622-3622/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 08:23:47.370 3622-3622/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n04-17 08:23:47.505 3622-3622/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n04-17 08:23:47.505 3622-3622/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n\n```\n\nView的dispatchTouchEvent改为true\n\n```\n04-17 08:26:52.930 3721-3721/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n04-17 08:26:52.930 3721-3721/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 08:26:52.930 3721-3721/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 08:26:52.930 3721-3721/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn\n\n```\n\n不再分发,不消费,会接收后续事件\n\nView的dispatchTouchEvent改为false\n\n```\n04-17 08:29:02.066 3822-3822/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n04-17 08:29:02.067 3822-3822/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 08:29:02.067 3822-3822/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 08:29:02.067 3822-3822/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn\n04-17 08:29:02.067 3822-3822/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 08:29:02.067 3822-3822/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n04-17 08:29:02.176 3822-3822/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n04-17 08:29:02.176 3822-3822/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n\n```\n\n不再分发.会传给外层布局的onTouchEvent进行消费,如果都不进行消费,则后续事件不再向内分发.\n\n只有View的dispatchTouchEvent为默认值时才会调View的onTouchEvent方法.\n\nViewGroup中\n\nonTouchEvent返回true\n\n\n```\n04-17 08:42:18.120 4533-4533/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n04-17 08:42:18.121 4533-4533/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 08:42:18.121 4533-4533/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 08:42:18.122 4533-4533/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn\n04-17 08:42:18.122 4533-4533/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn\n04-17 08:42:18.122 4533-4533/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 08:42:35.925 4533-4533/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n04-17 08:42:35.925 4533-4533/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 08:42:35.925 4533-4533/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyRela\n```\n消费之后会仍会分发给子类,如果子类不消费,后续事件不再分发给子类.\n\n于此同时把View的onTouchEvent方法改为true\n\n```\n04-17 08:44:28.544 4635-4635/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n04-17 08:44:28.545 4635-4635/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 08:44:28.545 4635-4635/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 08:44:28.545 4635-4635/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn\n04-17 08:44:28.545 4635-4635/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn\n04-17 08:44:34.966 4635-4635/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n04-17 08:44:34.966 4635-4635/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 08:44:34.966 4635-4635/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 08:44:34.966 4635-4635/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn\n04-17 08:44:34.966 4635-4635/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn\n```\n\n对ViewGroup的事件消费,且后续事件会传递到View中.\n\nonTouchEvent返回false\n\n```\n04-17 08:46:36.068 4735-4735/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n04-17 08:46:36.068 4735-4735/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 08:46:36.068 4735-4735/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 08:46:36.068 4735-4735/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn\n04-17 08:46:36.068 4735-4735/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn\n04-17 08:46:36.068 4735-4735/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 08:46:36.068 4735-4735/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n04-17 08:47:04.229 4735-4735/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n04-17 08:47:04.229 4735-4735/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n\n```\n\n不进行消费,当次事件会继续分发,如果子View不进行消费则后续事件不再分发进ViewGroup,如果子View进行消费,则后续事件仍会分发,只是不再经过ViewGroup的OntouchEvent()\n\n\n```\n04-17 08:50:15.560 5023-5023/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n04-17 08:50:15.560 5023-5023/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 08:50:15.560 5023-5023/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 08:50:15.560 5023-5023/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn\n04-17 08:50:15.560 5023-5023/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn\n04-17 08:50:19.491 5023-5023/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n04-17 08:50:19.491 5023-5023/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 08:50:19.491 5023-5023/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 08:50:19.491 5023-5023/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn\n04-17 08:50:19.491 5023-5023/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn\n```\nonInterceptTouchEvent返回true\n\n```\n04-17 08:53:53.191 5127-5127/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n04-17 08:53:53.193 5127-5127/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 08:53:53.193 5127-5127/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 08:53:53.193 5127-5127/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 08:53:53.193 5127-5127/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n04-17 08:54:08.389 5127-5127/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n04-17 08:54:08.389 5127-5127/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n\n```\n拦截后事件不会据需分发,会调用ViewGroup的OntouchVent,如果不进行消费,后续事件不会分发进来.\n\n与此同时,把onTOuchEvent的返回值改为true\n\n```\n04-17 08:56:00.350 5228-5228/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n04-17 08:56:00.350 5228-5228/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 08:56:00.350 5228-5228/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 08:56:00.351 5228-5228/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 08:56:02.535 5228-5228/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n04-17 08:56:02.535 5228-5228/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 08:56:02.535 5228-5228/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyRela\n```\n拦截之后进行消费,后续事件仍会继续分发,但不再调用拦截方法\n\n把dispatchTouchEvent返回true\n\n\n```\n04-17 09:00:31.695 5428-5428/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n04-17 09:00:31.695 5428-5428/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 09:00:31.813 5428-5428/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n04-17 09:00:31.814 5428-5428/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela\n\n```\n往外分发,仍接收后续事件 改为false\n\n```\n04-17 09:02:19.810 5529-5529/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n04-17 09:02:19.810 5529-5529/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 09:02:19.810 5529-5529/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n04-17 09:02:19.928 5529-5529/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n04-17 09:02:19.928 5529-5529/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n\n```\n向外分发,不再接收后续事件,会调用Activity的onTouchEvent()\n\nActivity中\n\ndispatchTouchEvent返回true或false\n\n\n```\n04-17 09:08:04.216 5728-5728/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n04-17 09:08:04.333 5728-5728/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n\n```\nonTouchEvent()改为true\n\n```\n04-17 09:09:23.950 5931-5931/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n04-17 09:09:23.950 5931-5931/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 09:09:23.951 5931-5931/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 09:09:23.951 5931-5931/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn\n04-17 09:09:23.951 5931-5931/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn\n04-17 09:09:23.951 5931-5931/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 09:09:23.951 5931-5931/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n04-17 09:09:24.094 5931-5931/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n04-17 09:09:24.094 5931-5931/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n\n```\n当次事件会继续分发,如果没有子控件消费,后续事件不再分发.直接调用onTouchEvent,\n\n于此同时把View中的onTouchEvent方法返回true\n\n```\n04-17 09:15:08.467 6031-6031/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n04-17 09:15:08.467 6031-6031/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 09:15:08.467 6031-6031/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 09:15:08.467 6031-6031/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn\n04-17 09:15:08.467 6031-6031/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn\n04-17 09:15:11.154 6031-6031/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n04-17 09:15:11.154 6031-6031/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 09:15:11.154 6031-6031/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 09:15:11.154 6031-6031/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn\n04-17 09:15:11.154 6031-6031/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn\n\n```\nView会先于Activity消费事件,且后续事件会继续分发到View\n\n把Activity的onTouchEvent()置为false,且子类不消费事件,则当次事件继续分发,后续事件不再分发,直接调用Activity的onTouchEvent方法.\n\n#### 参考\n[源码解析 - View的绘制流程](https://www.jianshu.com/p/1075d7d521ec)\n[Android 自定义View——View的绘制流程](https://www.jianshu.com/p/56006bc13dcf)\n[Android事件分发机制详解：史上最全面、最易懂](https://www.jianshu.com/p/38015afcdb58)\n\n\n\n\n","source":"_posts/关于面试(二).md","raw":"---\nlayout: post\ntitle: 关于面试(二)\ndate: 2019.7.19\nbody: [article,  comments]\nsidebar: false\ntag: [Android,面试]\ncategories: [Android]\n---\n#### view的绘制流程\nAndroid的UI管理系统层级关系\n![](https://coolyun1.oss-cn-shenzhen.aliyuncs.com/20190719141337.png)\n    View的绘制过程是从ViewRoot的performTraversals方法开始的，在其内部依次调用View的performMeasure,performLayout,performDraw三个方法。这三个方法分别完成顶级View的measure,layout,draw过程。其中，performMeasure中会调用measure方法，而在measure方法中又会调用onMeausre()方法，然后在onMeaure方法中会对所有的子元素进行measure过程，这时measure流程就从父容器传递到了子元素中，子元素会继续重复父容器的measure过程，如此反复即完成了整个View树结构的遍历，最终 完成View的测量过程。\n<!-- more -->\n    同理，performLayout和performDraw方法的传递流程和performMeasure类似，但不同的是，performDraw的传递是在draw方法中通过dispatchDraw方法来下发的，不过本质上原理还是一样的。下面给出一张流程图方便大家更好的理解：\n![](https://coolyun1.oss-cn-shenzhen.aliyuncs.com/20190719141403.png)\n只看一下主要几个方法:\n1. performMeasure\n\n```\nprivate void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) {\n        Trace.traceBegin(Trace.TRACE_TAG_VIEW, \"measure\");\n        try {\n            mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);\n        } finally {\n            Trace.traceEnd(Trace.TRACE_TAG_VIEW);\n        }\n    }\n```\n\n```\npublic final void measure(int widthMeasureSpec, int heightMeasureSpec) {\n         // 调用onMeasure()\n         onMeasure(widthMeasureSpec, heightMeasureSpec); \n    }\n```\n\n```\n@Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        if (mOrientation == VERTICAL) {\n            // 我们以垂直为例\n            measureVertical(widthMeasureSpec, heightMeasureSpec);\n        } else {\n            measureHorizontal(widthMeasureSpec, heightMeasureSpec);\n        }\n    }\n```\n\n```\nvoid measureVertical(int widthMeasureSpec, int heightMeasureSpec) {\n        // See how tall everyone is. Also remember max width.\n        for (int i = 0; i < count; ++i) {\n            final View child = getVirtualChildAt(i);\n            // 测量子孩子\n            measureChildBeforeLayout(child, i, widthMeasureSpec, 0,\n                        heightMeasureSpec, usedHeight);\n\n            final int childHeight = child.getMeasuredHeight();\n\n            final int totalLength = mTotalLength;\n            // 高度是子View的高度不断的叠加\n            mTotalLength = Math.max(totalLength, totalLength + childHeight + lp.topMargin +\n                       lp.bottomMargin + getNextLocationOffset(child));\n        }\n        int heightSize = mTotalLength;\n        // Check against our minimum height\n        heightSize = Math.max(heightSize, getSuggestedMinimumHeight());\n        \n        // Reconcile our calculated size with the heightMeasureSpec\n        int heightSizeAndState = resolveSizeAndState(heightSize, heightMeasureSpec, 0);\n        // 设置宽高\n        setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState),\n                heightSizeAndState);\n    }\n```\nViewGroup在调用onMeasure()方法的时候,会不断的循环测量子view.\n\n```\nvoid measureChildBeforeLayout(View child, int childIndex,\n            int widthMeasureSpec, int totalWidth, int heightMeasureSpec,\n            int totalHeight) {\n        measureChildWithMargins(child, widthMeasureSpec, totalWidth,\n                heightMeasureSpec, totalHeight);\n    }\n```\n\n```\nprotected void measureChildWithMargins(View child,\n            int parentWidthMeasureSpec, int widthUsed,\n            int parentHeightMeasureSpec, int heightUsed) {\n        final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();\n        //  getChildMeasureSpec 这个方法非常关键\n        final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,\n                mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin\n                        + widthUsed, lp.width);\n        final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,\n                mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin\n                        + heightUsed, lp.height);\n\n        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);\n    }\n```\n三种测量方式:\n![](https://coolyun1.oss-cn-shenzhen.aliyuncs.com/20190719141441.png)\n\n```\npublic static int getChildMeasureSpec(int spec, int padding, int childDimension) {\n        //获取当前Parent View的Mode和Size\n        int specMode = MeasureSpec.getMode(spec);\n        int specSize = MeasureSpec.getSize(spec);\n        //获取Parent size与padding差值（也就是Parent剩余大小），若差值小于0直接返回0\n        int size = Math.max(0, specSize - padding);\n        //定义返回值存储变量\n        int resultSize = 0;\n        int resultMode = 0;\n        //依据当前Parent的Mode进行switch分支逻辑\n        switch (specMode) {\n        // Parent has imposed an exact size on us\n        case MeasureSpec.EXACTLY:\n            if (childDimension >= 0) {\n                //如果child的layout_w和h属性在xml或者java中给予具体大于等于0的数值\n                //设置child的size为真实layout_w和h属性值，mode为EXACTLY\n                resultSize = childDimension;\n                resultMode = MeasureSpec.EXACTLY;\n            } else if (childDimension == LayoutParams.MATCH_PARENT) {\n                // Child wants to be our size. So be it.\n                //如果child的layout_wOrh属性在xml或者java中给予MATCH_PARENT\n                //设置child的size为size，mode为EXACTLY\n                resultSize = size;\n                resultMode = MeasureSpec.EXACTLY;\n            } else if (childDimension == LayoutParams.WRAP_CONTENT) {\n                // Child wants to determine its own size. It can't be\n                // bigger than us.\n                //如果child的layout_wOrh属性在xml或者java中给予WRAP_CONTENT\n                //设置child的size为size，mode为AT_MOST\n                resultSize = size;\n                resultMode = MeasureSpec.AT_MOST;\n            }\n            break;\n\n        // Parent has imposed a maximum size on us\n        case MeasureSpec.AT_MOST:\n            if (childDimension >= 0) {\n                // ......\n            } else if (childDimension == LayoutParams.MATCH_PARENT) {\n                // Child wants to be our size, but our size is not fixed.\n                // Constrain child to not be bigger than us.\n                // 如果父 View 是 AT_MOST 就算子 View 是 MATCH_PARENT，\n                // 其实子View获得的测量模式还是AT_MOST\n                resultSize = size;\n                resultMode = MeasureSpec.AT_MOST;\n            } else if (childDimension == LayoutParams.WRAP_CONTENT) {\n                // Child wants to determine its own size. It can't be\n                // bigger than us.\n                resultSize = size;\n                resultMode = MeasureSpec.AT_MOST;\n            }\n            break;\n\n            // ......\n        }\n        //noinspection ResourceType\n        return MeasureSpec.makeMeasureSpec(resultSize, resultMode);\n    }\n```\nView的绘制流程第一步是onMeasure()，该方法用来测量和指定布局到底占多大的宽高，因为控件的宽高是由父布局和本身来决定的，所以测量是不断的往内走，而最终确定宽高是由内不断的往外走，是递归的方式。\n2. performLayout\n\n```\nprivate void performLayout(WindowManager.LayoutParams lp, int desiredWindowWidth,\n            int desiredWindowHeight) {\n        final View host = mView;\n        // 调用layout()方法\n        host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight());\n    }\n\n    public void layout(int l, int t, int r, int b) {\n        onLayout(changed, l, t, r, b);\n    }\n```\n\n```\n@Override\n    protected void onLayout(boolean changed, int l, int t, int r, int b) {\n        if (mOrientation == VERTICAL) {\n            // 我们以垂直为例\n            layoutVertical(l, t, r, b);\n        } else {\n            layoutHorizontal(l, t, r, b);\n        }\n    }\n```\n\n```\nvoid layoutVertical(int left, int top, int right, int bottom) {\n        final int paddingLeft = mPaddingLeft;\n\n        int childTop;\n        int childLeft;\n\n        // Where right end of child should go\n        //计算父窗口推荐的子View宽度\n        final int width = right - left;\n        //计算父窗口推荐的子View右侧位置\n        int childRight = width - mPaddingRight;\n\n        // Space available for child\n        //child可使用空间大小\n        int childSpace = width - paddingLeft - mPaddingRight;\n        //通过ViewGroup的getChildCount方法获取ViewGroup的子View个数\n        final int count = getVirtualChildCount();\n        //获取Gravity属性设置\n        final int majorGravity = mGravity & Gravity.VERTICAL_GRAVITY_MASK;\n        final int minorGravity = mGravity & Gravity.RELATIVE_HORIZONTAL_GRAVITY_MASK;\n        //依据majorGravity计算childTop的位置值\n        switch (majorGravity) {\n           case Gravity.BOTTOM:\n               // mTotalLength contains the padding already\n               childTop = mPaddingTop + bottom - top - mTotalLength;\n               break;\n\n               // mTotalLength contains the padding already\n           case Gravity.CENTER_VERTICAL:\n               childTop = mPaddingTop + (bottom - top - mTotalLength) / 2;\n               break;\n\n           case Gravity.TOP:\n           default:\n               childTop = mPaddingTop;\n               break;\n        }\n        //重点！！！开始遍历\n        for (int i = 0; i < count; i++) {\n            final View child = getVirtualChildAt(i);\n            if (child == null) {\n                childTop += measureNullChild(i);\n            } else if (child.getVisibility() != GONE) {\n                //LinearLayout中其子视图显示的宽和高由measure过程来决定的，因此measure过程的意义就是为layout过程提供视图显示范围的参考值\n                final int childWidth = child.getMeasuredWidth();\n                final int childHeight = child.getMeasuredHeight();\n                //获取子View的LayoutParams\n                final LinearLayout.LayoutParams lp =\n                        (LinearLayout.LayoutParams) child.getLayoutParams();\n\n                int gravity = lp.gravity;\n                if (gravity < 0) {\n                    gravity = minorGravity;\n                }\n                final int layoutDirection = getLayoutDirection();\n                final int absoluteGravity = Gravity.getAbsoluteGravity(gravity, layoutDirection);\n                //依据不同的absoluteGravity计算childLeft位置\n                switch (absoluteGravity & Gravity.HORIZONTAL_GRAVITY_MASK) {\n                    case Gravity.CENTER_HORIZONTAL:\n                        childLeft = paddingLeft + ((childSpace - childWidth) / 2)\n                                + lp.leftMargin - lp.rightMargin;\n                        break;\n\n                    case Gravity.RIGHT:\n                        childLeft = childRight - childWidth - lp.rightMargin;\n                        break;\n\n                    case Gravity.LEFT:\n                    default:\n                        childLeft = paddingLeft + lp.leftMargin;\n                        break;\n                }\n\n                if (hasDividerBeforeChildAt(i)) {\n                    childTop += mDividerHeight;\n                }\n\n                childTop += lp.topMargin;\n                //通过垂直排列计算调运child的layout设置child的位置\n                setChildFrame(child, childLeft, childTop + getLocationOffset(child),\n                        childWidth, childHeight);\n                childTop += childHeight + lp.bottomMargin + getNextLocationOffset(child);\n\n                i += getChildrenSkipCount(child, i);\n            }\n        }\n    }\n```\n从上面分析可以看出layout也是从顶层父View向子View的递归调用view.layout方法的过程，即父View根据第一步performMeasure，来获取子View所的布局大小和布局参数，将子View放在合适的位置上，不过这个方法没有再往外走，只是不断的往里面走。\n3. performDraw\n\n```\nprivate void performDraw() {\n        try {\n            draw(fullRedrawNeeded);\n        } finally {\n            mIsDrawing = false;\n            Trace.traceEnd(Trace.TRACE_TAG_VIEW);\n        }\n    }\n\n    private void draw(boolean fullRedrawNeeded) {\n        Surface surface = mSurface;\n        if (!surface.isValid()) {\n            return;\n        }\n        \n        if (!drawSoftware(surface, mAttachInfo, xOffset, yOffset, scalingRequired, dirty)) {\n            return;\n        }\n    }\n\n    private boolean drawSoftware(Surface surface, AttachInfo attachInfo, int xoff, int yoff,\n            boolean scalingRequired, Rect dirty) {\n        // Draw with software renderer.\n        final Canvas canvas;\n        final int left = dirty.left;\n        final int top = dirty.top;\n        final int right = dirty.right;\n        final int bottom = dirty.bottom;\n        canvas = mSurface.lockCanvas(dirty);\n        // ... ...\n        mView.draw(canvas);\n    }\n```\n#### 事件分发\n1. 事件类型(down,up,move,cancel),从手指借出屏幕到手指离开屏幕为一组事件\n![](https://coolyun1.oss-cn-shenzhen.aliyuncs.com/20190719141523.png)\n2. 事件分发的本质就是将点击事件传递到某个具体的view&处理的整个过程.\n3. 事件在Activity,ViewGroup,View中传递\n4. 事件分发由哪些方法协作完成\n![](https://coolyun1.oss-cn-shenzhen.aliyuncs.com/20190719141541.png)\n5. activity的事件分发:\n![](https://coolyun1.oss-cn-shenzhen.aliyuncs.com/20190719141600.png)\n![](https://coolyun1.oss-cn-shenzhen.aliyuncs.com/20190719141630.png)\n6. ViewGroup的事件分发:\n![](https://coolyun1.oss-cn-shenzhen.aliyuncs.com/20190719141645.png)\n7. View的事件分发:\n![](https://coolyun1.oss-cn-shenzhen.aliyuncs.com/20190719141703.png)\n![](https://coolyun1.oss-cn-shenzhen.aliyuncs.com/20190719141725.png)\n8. 总结\n![](https://coolyun1.oss-cn-shenzhen.aliyuncs.com/20190719141805.png)\n\n#### 测试\n从Activity到ViewGroup到View. Activity类中添加一下代码\n\n```\n@Override\n    public boolean onTouchEvent(MotionEvent event) {\n        Log.e(\"gao\", \"onTouchEvent: \"+this.getClass().getName());\n        return super.onTouchEvent(event);\n    }\n\n    @Override\n    public void onClick(View v) {\n        Log.e(\"gao\", \"onClick: \"+this.getClass().getName());\n    }\n\n    @Override\n    public boolean dispatchTouchEvent(MotionEvent ev) {\n        Log.e(\"gao\", \"dispatchTouchEvent: \"+this.getClass().getName());\n        return super.dispatchTouchEvent(ev);\n    }\n\n```\n ViewGroup中添加以下代码:\n\n \n```\n@Override\n    public boolean dispatchTouchEvent(MotionEvent ev) {\n        Log.e(\"gao\", \"dispatchTouchEvent: \"+this.getClass().getName());\n        return super.dispatchTouchEvent(ev);\n    }\n\n    @Override\n    public boolean onInterceptTouchEvent(MotionEvent ev) {\n        Log.e(\"gao\", \"onInterceptTouchEvent: \"+this.getClass().getName());\n        return super.onInterceptTouchEvent(ev);\n    }\n\n    @Override\n    public boolean onTouchEvent(MotionEvent event) {\n        Log.e(\"gao\", \"onTouchEvent: \"+this.getClass().getName());\n        return super.onTouchEvent(event);\n    }\n\n```\nView中添加以下代码:\n\n```\n@Override\n    public boolean onTouchEvent(MotionEvent event) {\n        Log.e(\"gao\", \"onTouchEvent: \"+this.getClass().getName());\n        return super.onTouchEvent(event);\n    }\n\n    @Override\n    public boolean dispatchTouchEvent(MotionEvent event) {\n        Log.e(\"gao\", \"dispatchTouchEvent: \"+this.getClass().getName());\n        return super.dispatchTouchEvent(event);\n    }\n\n```\n\n  默认情况下调用顺序:\n  \n```\n04-17 08:03:09.766 2887-2887/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n04-17 08:03:09.767 2887-2887/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 08:03:09.767 2887-2887/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 08:03:09.767 2887-2887/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn\n04-17 08:03:09.767 2887-2887/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn\n04-17 08:03:09.786 2887-2887/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 08:03:09.786 2887-2887/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n04-17 08:03:09.889 2887-2887/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n04-17 08:03:09.889 2887-2887/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n```\n\nview中touchEvent改为true\n\n```\n04-17 08:06:14.757 2992-2992/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n04-17 08:06:14.757 2992-2992/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 08:06:14.757 2992-2992/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 08:06:14.757 2992-2992/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn\n04-17 08:06:14.757 2992-2992/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn\n04-17 08:06:14.757 2992-2992/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n04-17 08:06:14.757 2992-2992/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 08:06:14.757 2992-2992/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 08:06:14.757 2992-2992/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn\n04-17 08:06:14.757 2992-2992/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn\n\n```\n\n事件传到View后不再往外传,因为已经被消费了 方法都调用了两遍是因为接收了down事件之后,up事件也传过来接收了\n\nview中touchEvent改为false\n\n```\n04-17 08:23:47.369 3622-3622/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n04-17 08:23:47.370 3622-3622/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 08:23:47.370 3622-3622/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 08:23:47.370 3622-3622/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn\n04-17 08:23:47.370 3622-3622/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn\n04-17 08:23:47.370 3622-3622/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 08:23:47.370 3622-3622/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n04-17 08:23:47.505 3622-3622/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n04-17 08:23:47.505 3622-3622/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n\n```\n\nView的dispatchTouchEvent改为true\n\n```\n04-17 08:26:52.930 3721-3721/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n04-17 08:26:52.930 3721-3721/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 08:26:52.930 3721-3721/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 08:26:52.930 3721-3721/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn\n\n```\n\n不再分发,不消费,会接收后续事件\n\nView的dispatchTouchEvent改为false\n\n```\n04-17 08:29:02.066 3822-3822/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n04-17 08:29:02.067 3822-3822/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 08:29:02.067 3822-3822/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 08:29:02.067 3822-3822/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn\n04-17 08:29:02.067 3822-3822/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 08:29:02.067 3822-3822/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n04-17 08:29:02.176 3822-3822/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n04-17 08:29:02.176 3822-3822/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n\n```\n\n不再分发.会传给外层布局的onTouchEvent进行消费,如果都不进行消费,则后续事件不再向内分发.\n\n只有View的dispatchTouchEvent为默认值时才会调View的onTouchEvent方法.\n\nViewGroup中\n\nonTouchEvent返回true\n\n\n```\n04-17 08:42:18.120 4533-4533/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n04-17 08:42:18.121 4533-4533/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 08:42:18.121 4533-4533/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 08:42:18.122 4533-4533/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn\n04-17 08:42:18.122 4533-4533/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn\n04-17 08:42:18.122 4533-4533/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 08:42:35.925 4533-4533/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n04-17 08:42:35.925 4533-4533/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 08:42:35.925 4533-4533/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyRela\n```\n消费之后会仍会分发给子类,如果子类不消费,后续事件不再分发给子类.\n\n于此同时把View的onTouchEvent方法改为true\n\n```\n04-17 08:44:28.544 4635-4635/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n04-17 08:44:28.545 4635-4635/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 08:44:28.545 4635-4635/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 08:44:28.545 4635-4635/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn\n04-17 08:44:28.545 4635-4635/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn\n04-17 08:44:34.966 4635-4635/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n04-17 08:44:34.966 4635-4635/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 08:44:34.966 4635-4635/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 08:44:34.966 4635-4635/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn\n04-17 08:44:34.966 4635-4635/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn\n```\n\n对ViewGroup的事件消费,且后续事件会传递到View中.\n\nonTouchEvent返回false\n\n```\n04-17 08:46:36.068 4735-4735/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n04-17 08:46:36.068 4735-4735/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 08:46:36.068 4735-4735/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 08:46:36.068 4735-4735/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn\n04-17 08:46:36.068 4735-4735/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn\n04-17 08:46:36.068 4735-4735/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 08:46:36.068 4735-4735/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n04-17 08:47:04.229 4735-4735/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n04-17 08:47:04.229 4735-4735/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n\n```\n\n不进行消费,当次事件会继续分发,如果子View不进行消费则后续事件不再分发进ViewGroup,如果子View进行消费,则后续事件仍会分发,只是不再经过ViewGroup的OntouchEvent()\n\n\n```\n04-17 08:50:15.560 5023-5023/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n04-17 08:50:15.560 5023-5023/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 08:50:15.560 5023-5023/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 08:50:15.560 5023-5023/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn\n04-17 08:50:15.560 5023-5023/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn\n04-17 08:50:19.491 5023-5023/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n04-17 08:50:19.491 5023-5023/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 08:50:19.491 5023-5023/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 08:50:19.491 5023-5023/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn\n04-17 08:50:19.491 5023-5023/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn\n```\nonInterceptTouchEvent返回true\n\n```\n04-17 08:53:53.191 5127-5127/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n04-17 08:53:53.193 5127-5127/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 08:53:53.193 5127-5127/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 08:53:53.193 5127-5127/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 08:53:53.193 5127-5127/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n04-17 08:54:08.389 5127-5127/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n04-17 08:54:08.389 5127-5127/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n\n```\n拦截后事件不会据需分发,会调用ViewGroup的OntouchVent,如果不进行消费,后续事件不会分发进来.\n\n与此同时,把onTOuchEvent的返回值改为true\n\n```\n04-17 08:56:00.350 5228-5228/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n04-17 08:56:00.350 5228-5228/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 08:56:00.350 5228-5228/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 08:56:00.351 5228-5228/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 08:56:02.535 5228-5228/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n04-17 08:56:02.535 5228-5228/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 08:56:02.535 5228-5228/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyRela\n```\n拦截之后进行消费,后续事件仍会继续分发,但不再调用拦截方法\n\n把dispatchTouchEvent返回true\n\n\n```\n04-17 09:00:31.695 5428-5428/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n04-17 09:00:31.695 5428-5428/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 09:00:31.813 5428-5428/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n04-17 09:00:31.814 5428-5428/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela\n\n```\n往外分发,仍接收后续事件 改为false\n\n```\n04-17 09:02:19.810 5529-5529/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n04-17 09:02:19.810 5529-5529/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 09:02:19.810 5529-5529/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n04-17 09:02:19.928 5529-5529/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n04-17 09:02:19.928 5529-5529/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n\n```\n向外分发,不再接收后续事件,会调用Activity的onTouchEvent()\n\nActivity中\n\ndispatchTouchEvent返回true或false\n\n\n```\n04-17 09:08:04.216 5728-5728/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n04-17 09:08:04.333 5728-5728/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n\n```\nonTouchEvent()改为true\n\n```\n04-17 09:09:23.950 5931-5931/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n04-17 09:09:23.950 5931-5931/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 09:09:23.951 5931-5931/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 09:09:23.951 5931-5931/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn\n04-17 09:09:23.951 5931-5931/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn\n04-17 09:09:23.951 5931-5931/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 09:09:23.951 5931-5931/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n04-17 09:09:24.094 5931-5931/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n04-17 09:09:24.094 5931-5931/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n\n```\n当次事件会继续分发,如果没有子控件消费,后续事件不再分发.直接调用onTouchEvent,\n\n于此同时把View中的onTouchEvent方法返回true\n\n```\n04-17 09:15:08.467 6031-6031/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n04-17 09:15:08.467 6031-6031/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 09:15:08.467 6031-6031/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 09:15:08.467 6031-6031/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn\n04-17 09:15:08.467 6031-6031/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn\n04-17 09:15:11.154 6031-6031/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity\n04-17 09:15:11.154 6031-6031/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 09:15:11.154 6031-6031/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela\n04-17 09:15:11.154 6031-6031/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn\n04-17 09:15:11.154 6031-6031/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn\n\n```\nView会先于Activity消费事件,且后续事件会继续分发到View\n\n把Activity的onTouchEvent()置为false,且子类不消费事件,则当次事件继续分发,后续事件不再分发,直接调用Activity的onTouchEvent方法.\n\n#### 参考\n[源码解析 - View的绘制流程](https://www.jianshu.com/p/1075d7d521ec)\n[Android 自定义View——View的绘制流程](https://www.jianshu.com/p/56006bc13dcf)\n[Android事件分发机制详解：史上最全面、最易懂](https://www.jianshu.com/p/38015afcdb58)\n\n\n\n\n","slug":"关于面试(二)","published":1,"updated":"2019-07-19T06:18:13.000Z","comments":1,"photos":[],"link":"","_id":"ck03xfcbd000n4frrc9gjlbfw","content":"<h4 id=\"view的绘制流程\"><a href=\"#view的绘制流程\" class=\"headerlink\" title=\"view的绘制流程\"></a>view的绘制流程</h4><p>Android的UI管理系统层级关系<br><img src=\"https://coolyun1.oss-cn-shenzhen.aliyuncs.com/20190719141337.png\" alt><br>    View的绘制过程是从ViewRoot的performTraversals方法开始的，在其内部依次调用View的performMeasure,performLayout,performDraw三个方法。这三个方法分别完成顶级View的measure,layout,draw过程。其中，performMeasure中会调用measure方法，而在measure方法中又会调用onMeausre()方法，然后在onMeaure方法中会对所有的子元素进行measure过程，这时measure流程就从父容器传递到了子元素中，子元素会继续重复父容器的measure过程，如此反复即完成了整个View树结构的遍历，最终 完成View的测量过程。</p>\n<a id=\"more\"></a>\n<pre><code>同理，performLayout和performDraw方法的传递流程和performMeasure类似，但不同的是，performDraw的传递是在draw方法中通过dispatchDraw方法来下发的，不过本质上原理还是一样的。下面给出一张流程图方便大家更好的理解：</code></pre><p><img src=\"https://coolyun1.oss-cn-shenzhen.aliyuncs.com/20190719141403.png\" alt><br>只看一下主要几个方法:</p>\n<ol>\n<li>performMeasure</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) &#123;</span><br><span class=\"line\">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;measure&quot;);</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class=\"line\">        &#125; finally &#123;</span><br><span class=\"line\">            Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public final void measure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class=\"line\">         // 调用onMeasure()</span><br><span class=\"line\">         onMeasure(widthMeasureSpec, heightMeasureSpec); </span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class=\"line\">        if (mOrientation == VERTICAL) &#123;</span><br><span class=\"line\">            // 我们以垂直为例</span><br><span class=\"line\">            measureVertical(widthMeasureSpec, heightMeasureSpec);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            measureHorizontal(widthMeasureSpec, heightMeasureSpec);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void measureVertical(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class=\"line\">        // See how tall everyone is. Also remember max width.</span><br><span class=\"line\">        for (int i = 0; i &lt; count; ++i) &#123;</span><br><span class=\"line\">            final View child = getVirtualChildAt(i);</span><br><span class=\"line\">            // 测量子孩子</span><br><span class=\"line\">            measureChildBeforeLayout(child, i, widthMeasureSpec, 0,</span><br><span class=\"line\">                        heightMeasureSpec, usedHeight);</span><br><span class=\"line\"></span><br><span class=\"line\">            final int childHeight = child.getMeasuredHeight();</span><br><span class=\"line\"></span><br><span class=\"line\">            final int totalLength = mTotalLength;</span><br><span class=\"line\">            // 高度是子View的高度不断的叠加</span><br><span class=\"line\">            mTotalLength = Math.max(totalLength, totalLength + childHeight + lp.topMargin +</span><br><span class=\"line\">                       lp.bottomMargin + getNextLocationOffset(child));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        int heightSize = mTotalLength;</span><br><span class=\"line\">        // Check against our minimum height</span><br><span class=\"line\">        heightSize = Math.max(heightSize, getSuggestedMinimumHeight());</span><br><span class=\"line\">        </span><br><span class=\"line\">        // Reconcile our calculated size with the heightMeasureSpec</span><br><span class=\"line\">        int heightSizeAndState = resolveSizeAndState(heightSize, heightMeasureSpec, 0);</span><br><span class=\"line\">        // 设置宽高</span><br><span class=\"line\">        setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState),</span><br><span class=\"line\">                heightSizeAndState);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>ViewGroup在调用onMeasure()方法的时候,会不断的循环测量子view.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void measureChildBeforeLayout(View child, int childIndex,</span><br><span class=\"line\">            int widthMeasureSpec, int totalWidth, int heightMeasureSpec,</span><br><span class=\"line\">            int totalHeight) &#123;</span><br><span class=\"line\">        measureChildWithMargins(child, widthMeasureSpec, totalWidth,</span><br><span class=\"line\">                heightMeasureSpec, totalHeight);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protected void measureChildWithMargins(View child,</span><br><span class=\"line\">            int parentWidthMeasureSpec, int widthUsed,</span><br><span class=\"line\">            int parentHeightMeasureSpec, int heightUsed) &#123;</span><br><span class=\"line\">        final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</span><br><span class=\"line\">        //  getChildMeasureSpec 这个方法非常关键</span><br><span class=\"line\">        final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</span><br><span class=\"line\">                mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin</span><br><span class=\"line\">                        + widthUsed, lp.width);</span><br><span class=\"line\">        final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</span><br><span class=\"line\">                mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin</span><br><span class=\"line\">                        + heightUsed, lp.height);</span><br><span class=\"line\"></span><br><span class=\"line\">        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>三种测量方式:<br><img src=\"https://coolyun1.oss-cn-shenzhen.aliyuncs.com/20190719141441.png\" alt></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static int getChildMeasureSpec(int spec, int padding, int childDimension) &#123;</span><br><span class=\"line\">        //获取当前Parent View的Mode和Size</span><br><span class=\"line\">        int specMode = MeasureSpec.getMode(spec);</span><br><span class=\"line\">        int specSize = MeasureSpec.getSize(spec);</span><br><span class=\"line\">        //获取Parent size与padding差值（也就是Parent剩余大小），若差值小于0直接返回0</span><br><span class=\"line\">        int size = Math.max(0, specSize - padding);</span><br><span class=\"line\">        //定义返回值存储变量</span><br><span class=\"line\">        int resultSize = 0;</span><br><span class=\"line\">        int resultMode = 0;</span><br><span class=\"line\">        //依据当前Parent的Mode进行switch分支逻辑</span><br><span class=\"line\">        switch (specMode) &#123;</span><br><span class=\"line\">        // Parent has imposed an exact size on us</span><br><span class=\"line\">        case MeasureSpec.EXACTLY:</span><br><span class=\"line\">            if (childDimension &gt;= 0) &#123;</span><br><span class=\"line\">                //如果child的layout_w和h属性在xml或者java中给予具体大于等于0的数值</span><br><span class=\"line\">                //设置child的size为真实layout_w和h属性值，mode为EXACTLY</span><br><span class=\"line\">                resultSize = childDimension;</span><br><span class=\"line\">                resultMode = MeasureSpec.EXACTLY;</span><br><span class=\"line\">            &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class=\"line\">                // Child wants to be our size. So be it.</span><br><span class=\"line\">                //如果child的layout_wOrh属性在xml或者java中给予MATCH_PARENT</span><br><span class=\"line\">                //设置child的size为size，mode为EXACTLY</span><br><span class=\"line\">                resultSize = size;</span><br><span class=\"line\">                resultMode = MeasureSpec.EXACTLY;</span><br><span class=\"line\">            &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class=\"line\">                // Child wants to determine its own size. It can&apos;t be</span><br><span class=\"line\">                // bigger than us.</span><br><span class=\"line\">                //如果child的layout_wOrh属性在xml或者java中给予WRAP_CONTENT</span><br><span class=\"line\">                //设置child的size为size，mode为AT_MOST</span><br><span class=\"line\">                resultSize = size;</span><br><span class=\"line\">                resultMode = MeasureSpec.AT_MOST;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            break;</span><br><span class=\"line\"></span><br><span class=\"line\">        // Parent has imposed a maximum size on us</span><br><span class=\"line\">        case MeasureSpec.AT_MOST:</span><br><span class=\"line\">            if (childDimension &gt;= 0) &#123;</span><br><span class=\"line\">                // ......</span><br><span class=\"line\">            &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class=\"line\">                // Child wants to be our size, but our size is not fixed.</span><br><span class=\"line\">                // Constrain child to not be bigger than us.</span><br><span class=\"line\">                // 如果父 View 是 AT_MOST 就算子 View 是 MATCH_PARENT，</span><br><span class=\"line\">                // 其实子View获得的测量模式还是AT_MOST</span><br><span class=\"line\">                resultSize = size;</span><br><span class=\"line\">                resultMode = MeasureSpec.AT_MOST;</span><br><span class=\"line\">            &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class=\"line\">                // Child wants to determine its own size. It can&apos;t be</span><br><span class=\"line\">                // bigger than us.</span><br><span class=\"line\">                resultSize = size;</span><br><span class=\"line\">                resultMode = MeasureSpec.AT_MOST;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            break;</span><br><span class=\"line\"></span><br><span class=\"line\">            // ......</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        //noinspection ResourceType</span><br><span class=\"line\">        return MeasureSpec.makeMeasureSpec(resultSize, resultMode);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>View的绘制流程第一步是onMeasure()，该方法用来测量和指定布局到底占多大的宽高，因为控件的宽高是由父布局和本身来决定的，所以测量是不断的往内走，而最终确定宽高是由内不断的往外走，是递归的方式。</p>\n<ol start=\"2\">\n<li>performLayout</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void performLayout(WindowManager.LayoutParams lp, int desiredWindowWidth,</span><br><span class=\"line\">            int desiredWindowHeight) &#123;</span><br><span class=\"line\">        final View host = mView;</span><br><span class=\"line\">        // 调用layout()方法</span><br><span class=\"line\">        host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void layout(int l, int t, int r, int b) &#123;</span><br><span class=\"line\">        onLayout(changed, l, t, r, b);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">    protected void onLayout(boolean changed, int l, int t, int r, int b) &#123;</span><br><span class=\"line\">        if (mOrientation == VERTICAL) &#123;</span><br><span class=\"line\">            // 我们以垂直为例</span><br><span class=\"line\">            layoutVertical(l, t, r, b);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            layoutHorizontal(l, t, r, b);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void layoutVertical(int left, int top, int right, int bottom) &#123;</span><br><span class=\"line\">        final int paddingLeft = mPaddingLeft;</span><br><span class=\"line\"></span><br><span class=\"line\">        int childTop;</span><br><span class=\"line\">        int childLeft;</span><br><span class=\"line\"></span><br><span class=\"line\">        // Where right end of child should go</span><br><span class=\"line\">        //计算父窗口推荐的子View宽度</span><br><span class=\"line\">        final int width = right - left;</span><br><span class=\"line\">        //计算父窗口推荐的子View右侧位置</span><br><span class=\"line\">        int childRight = width - mPaddingRight;</span><br><span class=\"line\"></span><br><span class=\"line\">        // Space available for child</span><br><span class=\"line\">        //child可使用空间大小</span><br><span class=\"line\">        int childSpace = width - paddingLeft - mPaddingRight;</span><br><span class=\"line\">        //通过ViewGroup的getChildCount方法获取ViewGroup的子View个数</span><br><span class=\"line\">        final int count = getVirtualChildCount();</span><br><span class=\"line\">        //获取Gravity属性设置</span><br><span class=\"line\">        final int majorGravity = mGravity &amp; Gravity.VERTICAL_GRAVITY_MASK;</span><br><span class=\"line\">        final int minorGravity = mGravity &amp; Gravity.RELATIVE_HORIZONTAL_GRAVITY_MASK;</span><br><span class=\"line\">        //依据majorGravity计算childTop的位置值</span><br><span class=\"line\">        switch (majorGravity) &#123;</span><br><span class=\"line\">           case Gravity.BOTTOM:</span><br><span class=\"line\">               // mTotalLength contains the padding already</span><br><span class=\"line\">               childTop = mPaddingTop + bottom - top - mTotalLength;</span><br><span class=\"line\">               break;</span><br><span class=\"line\"></span><br><span class=\"line\">               // mTotalLength contains the padding already</span><br><span class=\"line\">           case Gravity.CENTER_VERTICAL:</span><br><span class=\"line\">               childTop = mPaddingTop + (bottom - top - mTotalLength) / 2;</span><br><span class=\"line\">               break;</span><br><span class=\"line\"></span><br><span class=\"line\">           case Gravity.TOP:</span><br><span class=\"line\">           default:</span><br><span class=\"line\">               childTop = mPaddingTop;</span><br><span class=\"line\">               break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        //重点！！！开始遍历</span><br><span class=\"line\">        for (int i = 0; i &lt; count; i++) &#123;</span><br><span class=\"line\">            final View child = getVirtualChildAt(i);</span><br><span class=\"line\">            if (child == null) &#123;</span><br><span class=\"line\">                childTop += measureNullChild(i);</span><br><span class=\"line\">            &#125; else if (child.getVisibility() != GONE) &#123;</span><br><span class=\"line\">                //LinearLayout中其子视图显示的宽和高由measure过程来决定的，因此measure过程的意义就是为layout过程提供视图显示范围的参考值</span><br><span class=\"line\">                final int childWidth = child.getMeasuredWidth();</span><br><span class=\"line\">                final int childHeight = child.getMeasuredHeight();</span><br><span class=\"line\">                //获取子View的LayoutParams</span><br><span class=\"line\">                final LinearLayout.LayoutParams lp =</span><br><span class=\"line\">                        (LinearLayout.LayoutParams) child.getLayoutParams();</span><br><span class=\"line\"></span><br><span class=\"line\">                int gravity = lp.gravity;</span><br><span class=\"line\">                if (gravity &lt; 0) &#123;</span><br><span class=\"line\">                    gravity = minorGravity;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                final int layoutDirection = getLayoutDirection();</span><br><span class=\"line\">                final int absoluteGravity = Gravity.getAbsoluteGravity(gravity, layoutDirection);</span><br><span class=\"line\">                //依据不同的absoluteGravity计算childLeft位置</span><br><span class=\"line\">                switch (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) &#123;</span><br><span class=\"line\">                    case Gravity.CENTER_HORIZONTAL:</span><br><span class=\"line\">                        childLeft = paddingLeft + ((childSpace - childWidth) / 2)</span><br><span class=\"line\">                                + lp.leftMargin - lp.rightMargin;</span><br><span class=\"line\">                        break;</span><br><span class=\"line\"></span><br><span class=\"line\">                    case Gravity.RIGHT:</span><br><span class=\"line\">                        childLeft = childRight - childWidth - lp.rightMargin;</span><br><span class=\"line\">                        break;</span><br><span class=\"line\"></span><br><span class=\"line\">                    case Gravity.LEFT:</span><br><span class=\"line\">                    default:</span><br><span class=\"line\">                        childLeft = paddingLeft + lp.leftMargin;</span><br><span class=\"line\">                        break;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                if (hasDividerBeforeChildAt(i)) &#123;</span><br><span class=\"line\">                    childTop += mDividerHeight;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                childTop += lp.topMargin;</span><br><span class=\"line\">                //通过垂直排列计算调运child的layout设置child的位置</span><br><span class=\"line\">                setChildFrame(child, childLeft, childTop + getLocationOffset(child),</span><br><span class=\"line\">                        childWidth, childHeight);</span><br><span class=\"line\">                childTop += childHeight + lp.bottomMargin + getNextLocationOffset(child);</span><br><span class=\"line\"></span><br><span class=\"line\">                i += getChildrenSkipCount(child, i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>从上面分析可以看出layout也是从顶层父View向子View的递归调用view.layout方法的过程，即父View根据第一步performMeasure，来获取子View所的布局大小和布局参数，将子View放在合适的位置上，不过这个方法没有再往外走，只是不断的往里面走。</p>\n<ol start=\"3\">\n<li>performDraw</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void performDraw() &#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            draw(fullRedrawNeeded);</span><br><span class=\"line\">        &#125; finally &#123;</span><br><span class=\"line\">            mIsDrawing = false;</span><br><span class=\"line\">            Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private void draw(boolean fullRedrawNeeded) &#123;</span><br><span class=\"line\">        Surface surface = mSurface;</span><br><span class=\"line\">        if (!surface.isValid()) &#123;</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        if (!drawSoftware(surface, mAttachInfo, xOffset, yOffset, scalingRequired, dirty)) &#123;</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private boolean drawSoftware(Surface surface, AttachInfo attachInfo, int xoff, int yoff,</span><br><span class=\"line\">            boolean scalingRequired, Rect dirty) &#123;</span><br><span class=\"line\">        // Draw with software renderer.</span><br><span class=\"line\">        final Canvas canvas;</span><br><span class=\"line\">        final int left = dirty.left;</span><br><span class=\"line\">        final int top = dirty.top;</span><br><span class=\"line\">        final int right = dirty.right;</span><br><span class=\"line\">        final int bottom = dirty.bottom;</span><br><span class=\"line\">        canvas = mSurface.lockCanvas(dirty);</span><br><span class=\"line\">        // ... ...</span><br><span class=\"line\">        mView.draw(canvas);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"事件分发\"><a href=\"#事件分发\" class=\"headerlink\" title=\"事件分发\"></a>事件分发</h4><ol>\n<li>事件类型(down,up,move,cancel),从手指借出屏幕到手指离开屏幕为一组事件<br><img src=\"https://coolyun1.oss-cn-shenzhen.aliyuncs.com/20190719141523.png\" alt></li>\n<li>事件分发的本质就是将点击事件传递到某个具体的view&amp;处理的整个过程.</li>\n<li>事件在Activity,ViewGroup,View中传递</li>\n<li>事件分发由哪些方法协作完成<br><img src=\"https://coolyun1.oss-cn-shenzhen.aliyuncs.com/20190719141541.png\" alt></li>\n<li>activity的事件分发:<br><img src=\"https://coolyun1.oss-cn-shenzhen.aliyuncs.com/20190719141600.png\" alt><br><img src=\"https://coolyun1.oss-cn-shenzhen.aliyuncs.com/20190719141630.png\" alt></li>\n<li>ViewGroup的事件分发:<br><img src=\"https://coolyun1.oss-cn-shenzhen.aliyuncs.com/20190719141645.png\" alt></li>\n<li>View的事件分发:<br><img src=\"https://coolyun1.oss-cn-shenzhen.aliyuncs.com/20190719141703.png\" alt><br><img src=\"https://coolyun1.oss-cn-shenzhen.aliyuncs.com/20190719141725.png\" alt></li>\n<li>总结<br><img src=\"https://coolyun1.oss-cn-shenzhen.aliyuncs.com/20190719141805.png\" alt></li>\n</ol>\n<h4 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h4><p>从Activity到ViewGroup到View. Activity类中添加一下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">    public boolean onTouchEvent(MotionEvent event) &#123;</span><br><span class=\"line\">        Log.e(&quot;gao&quot;, &quot;onTouchEvent: &quot;+this.getClass().getName());</span><br><span class=\"line\">        return super.onTouchEvent(event);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onClick(View v) &#123;</span><br><span class=\"line\">        Log.e(&quot;gao&quot;, &quot;onClick: &quot;+this.getClass().getName());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public boolean dispatchTouchEvent(MotionEvent ev) &#123;</span><br><span class=\"line\">        Log.e(&quot;gao&quot;, &quot;dispatchTouchEvent: &quot;+this.getClass().getName());</span><br><span class=\"line\">        return super.dispatchTouchEvent(ev);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p> ViewGroup中添加以下代码:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">    public boolean dispatchTouchEvent(MotionEvent ev) &#123;</span><br><span class=\"line\">        Log.e(&quot;gao&quot;, &quot;dispatchTouchEvent: &quot;+this.getClass().getName());</span><br><span class=\"line\">        return super.dispatchTouchEvent(ev);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public boolean onInterceptTouchEvent(MotionEvent ev) &#123;</span><br><span class=\"line\">        Log.e(&quot;gao&quot;, &quot;onInterceptTouchEvent: &quot;+this.getClass().getName());</span><br><span class=\"line\">        return super.onInterceptTouchEvent(ev);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public boolean onTouchEvent(MotionEvent event) &#123;</span><br><span class=\"line\">        Log.e(&quot;gao&quot;, &quot;onTouchEvent: &quot;+this.getClass().getName());</span><br><span class=\"line\">        return super.onTouchEvent(event);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>View中添加以下代码:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">    public boolean onTouchEvent(MotionEvent event) &#123;</span><br><span class=\"line\">        Log.e(&quot;gao&quot;, &quot;onTouchEvent: &quot;+this.getClass().getName());</span><br><span class=\"line\">        return super.onTouchEvent(event);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public boolean dispatchTouchEvent(MotionEvent event) &#123;</span><br><span class=\"line\">        Log.e(&quot;gao&quot;, &quot;dispatchTouchEvent: &quot;+this.getClass().getName());</span><br><span class=\"line\">        return super.dispatchTouchEvent(event);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>  默认情况下调用顺序:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">04-17 08:03:09.766 2887-2887/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class=\"line\">04-17 08:03:09.767 2887-2887/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 08:03:09.767 2887-2887/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 08:03:09.767 2887-2887/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn</span><br><span class=\"line\">04-17 08:03:09.767 2887-2887/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn</span><br><span class=\"line\">04-17 08:03:09.786 2887-2887/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 08:03:09.786 2887-2887/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class=\"line\">04-17 08:03:09.889 2887-2887/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class=\"line\">04-17 08:03:09.889 2887-2887/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br></pre></td></tr></table></figure>\n\n<p>view中touchEvent改为true</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">04-17 08:06:14.757 2992-2992/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class=\"line\">04-17 08:06:14.757 2992-2992/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 08:06:14.757 2992-2992/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 08:06:14.757 2992-2992/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn</span><br><span class=\"line\">04-17 08:06:14.757 2992-2992/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn</span><br><span class=\"line\">04-17 08:06:14.757 2992-2992/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class=\"line\">04-17 08:06:14.757 2992-2992/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 08:06:14.757 2992-2992/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 08:06:14.757 2992-2992/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn</span><br><span class=\"line\">04-17 08:06:14.757 2992-2992/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn</span><br></pre></td></tr></table></figure>\n\n<p>事件传到View后不再往外传,因为已经被消费了 方法都调用了两遍是因为接收了down事件之后,up事件也传过来接收了</p>\n<p>view中touchEvent改为false</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">04-17 08:23:47.369 3622-3622/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class=\"line\">04-17 08:23:47.370 3622-3622/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 08:23:47.370 3622-3622/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 08:23:47.370 3622-3622/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn</span><br><span class=\"line\">04-17 08:23:47.370 3622-3622/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn</span><br><span class=\"line\">04-17 08:23:47.370 3622-3622/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 08:23:47.370 3622-3622/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class=\"line\">04-17 08:23:47.505 3622-3622/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class=\"line\">04-17 08:23:47.505 3622-3622/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br></pre></td></tr></table></figure>\n\n<p>View的dispatchTouchEvent改为true</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">04-17 08:26:52.930 3721-3721/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class=\"line\">04-17 08:26:52.930 3721-3721/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 08:26:52.930 3721-3721/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 08:26:52.930 3721-3721/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn</span><br></pre></td></tr></table></figure>\n\n<p>不再分发,不消费,会接收后续事件</p>\n<p>View的dispatchTouchEvent改为false</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">04-17 08:29:02.066 3822-3822/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class=\"line\">04-17 08:29:02.067 3822-3822/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 08:29:02.067 3822-3822/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 08:29:02.067 3822-3822/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn</span><br><span class=\"line\">04-17 08:29:02.067 3822-3822/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 08:29:02.067 3822-3822/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class=\"line\">04-17 08:29:02.176 3822-3822/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class=\"line\">04-17 08:29:02.176 3822-3822/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br></pre></td></tr></table></figure>\n\n<p>不再分发.会传给外层布局的onTouchEvent进行消费,如果都不进行消费,则后续事件不再向内分发.</p>\n<p>只有View的dispatchTouchEvent为默认值时才会调View的onTouchEvent方法.</p>\n<p>ViewGroup中</p>\n<p>onTouchEvent返回true</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">04-17 08:42:18.120 4533-4533/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class=\"line\">04-17 08:42:18.121 4533-4533/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 08:42:18.121 4533-4533/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 08:42:18.122 4533-4533/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn</span><br><span class=\"line\">04-17 08:42:18.122 4533-4533/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn</span><br><span class=\"line\">04-17 08:42:18.122 4533-4533/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 08:42:35.925 4533-4533/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class=\"line\">04-17 08:42:35.925 4533-4533/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 08:42:35.925 4533-4533/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br></pre></td></tr></table></figure>\n\n<p>消费之后会仍会分发给子类,如果子类不消费,后续事件不再分发给子类.</p>\n<p>于此同时把View的onTouchEvent方法改为true</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">04-17 08:44:28.544 4635-4635/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class=\"line\">04-17 08:44:28.545 4635-4635/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 08:44:28.545 4635-4635/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 08:44:28.545 4635-4635/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn</span><br><span class=\"line\">04-17 08:44:28.545 4635-4635/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn</span><br><span class=\"line\">04-17 08:44:34.966 4635-4635/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class=\"line\">04-17 08:44:34.966 4635-4635/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 08:44:34.966 4635-4635/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 08:44:34.966 4635-4635/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn</span><br><span class=\"line\">04-17 08:44:34.966 4635-4635/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn</span><br></pre></td></tr></table></figure>\n\n<p>对ViewGroup的事件消费,且后续事件会传递到View中.</p>\n<p>onTouchEvent返回false</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">04-17 08:46:36.068 4735-4735/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class=\"line\">04-17 08:46:36.068 4735-4735/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 08:46:36.068 4735-4735/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 08:46:36.068 4735-4735/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn</span><br><span class=\"line\">04-17 08:46:36.068 4735-4735/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn</span><br><span class=\"line\">04-17 08:46:36.068 4735-4735/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 08:46:36.068 4735-4735/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class=\"line\">04-17 08:47:04.229 4735-4735/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class=\"line\">04-17 08:47:04.229 4735-4735/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br></pre></td></tr></table></figure>\n\n<p>不进行消费,当次事件会继续分发,如果子View不进行消费则后续事件不再分发进ViewGroup,如果子View进行消费,则后续事件仍会分发,只是不再经过ViewGroup的OntouchEvent()</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">04-17 08:50:15.560 5023-5023/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class=\"line\">04-17 08:50:15.560 5023-5023/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 08:50:15.560 5023-5023/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 08:50:15.560 5023-5023/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn</span><br><span class=\"line\">04-17 08:50:15.560 5023-5023/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn</span><br><span class=\"line\">04-17 08:50:19.491 5023-5023/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class=\"line\">04-17 08:50:19.491 5023-5023/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 08:50:19.491 5023-5023/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 08:50:19.491 5023-5023/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn</span><br><span class=\"line\">04-17 08:50:19.491 5023-5023/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn</span><br></pre></td></tr></table></figure>\n\n<p>onInterceptTouchEvent返回true</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">04-17 08:53:53.191 5127-5127/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class=\"line\">04-17 08:53:53.193 5127-5127/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 08:53:53.193 5127-5127/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 08:53:53.193 5127-5127/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 08:53:53.193 5127-5127/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class=\"line\">04-17 08:54:08.389 5127-5127/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class=\"line\">04-17 08:54:08.389 5127-5127/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br></pre></td></tr></table></figure>\n\n<p>拦截后事件不会据需分发,会调用ViewGroup的OntouchVent,如果不进行消费,后续事件不会分发进来.</p>\n<p>与此同时,把onTOuchEvent的返回值改为true</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">04-17 08:56:00.350 5228-5228/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class=\"line\">04-17 08:56:00.350 5228-5228/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 08:56:00.350 5228-5228/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 08:56:00.351 5228-5228/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 08:56:02.535 5228-5228/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class=\"line\">04-17 08:56:02.535 5228-5228/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 08:56:02.535 5228-5228/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br></pre></td></tr></table></figure>\n\n<p>拦截之后进行消费,后续事件仍会继续分发,但不再调用拦截方法</p>\n<p>把dispatchTouchEvent返回true</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">04-17 09:00:31.695 5428-5428/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class=\"line\">04-17 09:00:31.695 5428-5428/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 09:00:31.813 5428-5428/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class=\"line\">04-17 09:00:31.814 5428-5428/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br></pre></td></tr></table></figure>\n\n<p>往外分发,仍接收后续事件 改为false</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">04-17 09:02:19.810 5529-5529/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class=\"line\">04-17 09:02:19.810 5529-5529/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 09:02:19.810 5529-5529/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class=\"line\">04-17 09:02:19.928 5529-5529/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class=\"line\">04-17 09:02:19.928 5529-5529/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br></pre></td></tr></table></figure>\n\n<p>向外分发,不再接收后续事件,会调用Activity的onTouchEvent()</p>\n<p>Activity中</p>\n<p>dispatchTouchEvent返回true或false</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">04-17 09:08:04.216 5728-5728/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class=\"line\">04-17 09:08:04.333 5728-5728/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br></pre></td></tr></table></figure>\n\n<p>onTouchEvent()改为true</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">04-17 09:09:23.950 5931-5931/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class=\"line\">04-17 09:09:23.950 5931-5931/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 09:09:23.951 5931-5931/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 09:09:23.951 5931-5931/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn</span><br><span class=\"line\">04-17 09:09:23.951 5931-5931/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn</span><br><span class=\"line\">04-17 09:09:23.951 5931-5931/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 09:09:23.951 5931-5931/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class=\"line\">04-17 09:09:24.094 5931-5931/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class=\"line\">04-17 09:09:24.094 5931-5931/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br></pre></td></tr></table></figure>\n\n<p>当次事件会继续分发,如果没有子控件消费,后续事件不再分发.直接调用onTouchEvent,</p>\n<p>于此同时把View中的onTouchEvent方法返回true</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">04-17 09:15:08.467 6031-6031/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class=\"line\">04-17 09:15:08.467 6031-6031/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 09:15:08.467 6031-6031/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 09:15:08.467 6031-6031/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn</span><br><span class=\"line\">04-17 09:15:08.467 6031-6031/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn</span><br><span class=\"line\">04-17 09:15:11.154 6031-6031/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class=\"line\">04-17 09:15:11.154 6031-6031/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 09:15:11.154 6031-6031/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 09:15:11.154 6031-6031/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn</span><br><span class=\"line\">04-17 09:15:11.154 6031-6031/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn</span><br></pre></td></tr></table></figure>\n\n<p>View会先于Activity消费事件,且后续事件会继续分发到View</p>\n<p>把Activity的onTouchEvent()置为false,且子类不消费事件,则当次事件继续分发,后续事件不再分发,直接调用Activity的onTouchEvent方法.</p>\n<h4 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h4><p><a href=\"https://www.jianshu.com/p/1075d7d521ec\" target=\"_blank\" rel=\"noopener\">源码解析 - View的绘制流程</a><br><a href=\"https://www.jianshu.com/p/56006bc13dcf\" target=\"_blank\" rel=\"noopener\">Android 自定义View——View的绘制流程</a><br><a href=\"https://www.jianshu.com/p/38015afcdb58\" target=\"_blank\" rel=\"noopener\">Android事件分发机制详解：史上最全面、最易懂</a></p>\n","site":{"data":{}},"excerpt":"<h4 id=\"view的绘制流程\"><a href=\"#view的绘制流程\" class=\"headerlink\" title=\"view的绘制流程\"></a>view的绘制流程</h4><p>Android的UI管理系统层级关系<br><img src=\"https://coolyun1.oss-cn-shenzhen.aliyuncs.com/20190719141337.png\" alt><br>    View的绘制过程是从ViewRoot的performTraversals方法开始的，在其内部依次调用View的performMeasure,performLayout,performDraw三个方法。这三个方法分别完成顶级View的measure,layout,draw过程。其中，performMeasure中会调用measure方法，而在measure方法中又会调用onMeausre()方法，然后在onMeaure方法中会对所有的子元素进行measure过程，这时measure流程就从父容器传递到了子元素中，子元素会继续重复父容器的measure过程，如此反复即完成了整个View树结构的遍历，最终 完成View的测量过程。</p>","more":"<pre><code>同理，performLayout和performDraw方法的传递流程和performMeasure类似，但不同的是，performDraw的传递是在draw方法中通过dispatchDraw方法来下发的，不过本质上原理还是一样的。下面给出一张流程图方便大家更好的理解：</code></pre><p><img src=\"https://coolyun1.oss-cn-shenzhen.aliyuncs.com/20190719141403.png\" alt><br>只看一下主要几个方法:</p>\n<ol>\n<li>performMeasure</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) &#123;</span><br><span class=\"line\">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;measure&quot;);</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class=\"line\">        &#125; finally &#123;</span><br><span class=\"line\">            Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public final void measure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class=\"line\">         // 调用onMeasure()</span><br><span class=\"line\">         onMeasure(widthMeasureSpec, heightMeasureSpec); </span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class=\"line\">        if (mOrientation == VERTICAL) &#123;</span><br><span class=\"line\">            // 我们以垂直为例</span><br><span class=\"line\">            measureVertical(widthMeasureSpec, heightMeasureSpec);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            measureHorizontal(widthMeasureSpec, heightMeasureSpec);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void measureVertical(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class=\"line\">        // See how tall everyone is. Also remember max width.</span><br><span class=\"line\">        for (int i = 0; i &lt; count; ++i) &#123;</span><br><span class=\"line\">            final View child = getVirtualChildAt(i);</span><br><span class=\"line\">            // 测量子孩子</span><br><span class=\"line\">            measureChildBeforeLayout(child, i, widthMeasureSpec, 0,</span><br><span class=\"line\">                        heightMeasureSpec, usedHeight);</span><br><span class=\"line\"></span><br><span class=\"line\">            final int childHeight = child.getMeasuredHeight();</span><br><span class=\"line\"></span><br><span class=\"line\">            final int totalLength = mTotalLength;</span><br><span class=\"line\">            // 高度是子View的高度不断的叠加</span><br><span class=\"line\">            mTotalLength = Math.max(totalLength, totalLength + childHeight + lp.topMargin +</span><br><span class=\"line\">                       lp.bottomMargin + getNextLocationOffset(child));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        int heightSize = mTotalLength;</span><br><span class=\"line\">        // Check against our minimum height</span><br><span class=\"line\">        heightSize = Math.max(heightSize, getSuggestedMinimumHeight());</span><br><span class=\"line\">        </span><br><span class=\"line\">        // Reconcile our calculated size with the heightMeasureSpec</span><br><span class=\"line\">        int heightSizeAndState = resolveSizeAndState(heightSize, heightMeasureSpec, 0);</span><br><span class=\"line\">        // 设置宽高</span><br><span class=\"line\">        setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState),</span><br><span class=\"line\">                heightSizeAndState);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>ViewGroup在调用onMeasure()方法的时候,会不断的循环测量子view.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void measureChildBeforeLayout(View child, int childIndex,</span><br><span class=\"line\">            int widthMeasureSpec, int totalWidth, int heightMeasureSpec,</span><br><span class=\"line\">            int totalHeight) &#123;</span><br><span class=\"line\">        measureChildWithMargins(child, widthMeasureSpec, totalWidth,</span><br><span class=\"line\">                heightMeasureSpec, totalHeight);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protected void measureChildWithMargins(View child,</span><br><span class=\"line\">            int parentWidthMeasureSpec, int widthUsed,</span><br><span class=\"line\">            int parentHeightMeasureSpec, int heightUsed) &#123;</span><br><span class=\"line\">        final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</span><br><span class=\"line\">        //  getChildMeasureSpec 这个方法非常关键</span><br><span class=\"line\">        final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</span><br><span class=\"line\">                mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin</span><br><span class=\"line\">                        + widthUsed, lp.width);</span><br><span class=\"line\">        final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</span><br><span class=\"line\">                mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin</span><br><span class=\"line\">                        + heightUsed, lp.height);</span><br><span class=\"line\"></span><br><span class=\"line\">        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>三种测量方式:<br><img src=\"https://coolyun1.oss-cn-shenzhen.aliyuncs.com/20190719141441.png\" alt></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static int getChildMeasureSpec(int spec, int padding, int childDimension) &#123;</span><br><span class=\"line\">        //获取当前Parent View的Mode和Size</span><br><span class=\"line\">        int specMode = MeasureSpec.getMode(spec);</span><br><span class=\"line\">        int specSize = MeasureSpec.getSize(spec);</span><br><span class=\"line\">        //获取Parent size与padding差值（也就是Parent剩余大小），若差值小于0直接返回0</span><br><span class=\"line\">        int size = Math.max(0, specSize - padding);</span><br><span class=\"line\">        //定义返回值存储变量</span><br><span class=\"line\">        int resultSize = 0;</span><br><span class=\"line\">        int resultMode = 0;</span><br><span class=\"line\">        //依据当前Parent的Mode进行switch分支逻辑</span><br><span class=\"line\">        switch (specMode) &#123;</span><br><span class=\"line\">        // Parent has imposed an exact size on us</span><br><span class=\"line\">        case MeasureSpec.EXACTLY:</span><br><span class=\"line\">            if (childDimension &gt;= 0) &#123;</span><br><span class=\"line\">                //如果child的layout_w和h属性在xml或者java中给予具体大于等于0的数值</span><br><span class=\"line\">                //设置child的size为真实layout_w和h属性值，mode为EXACTLY</span><br><span class=\"line\">                resultSize = childDimension;</span><br><span class=\"line\">                resultMode = MeasureSpec.EXACTLY;</span><br><span class=\"line\">            &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class=\"line\">                // Child wants to be our size. So be it.</span><br><span class=\"line\">                //如果child的layout_wOrh属性在xml或者java中给予MATCH_PARENT</span><br><span class=\"line\">                //设置child的size为size，mode为EXACTLY</span><br><span class=\"line\">                resultSize = size;</span><br><span class=\"line\">                resultMode = MeasureSpec.EXACTLY;</span><br><span class=\"line\">            &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class=\"line\">                // Child wants to determine its own size. It can&apos;t be</span><br><span class=\"line\">                // bigger than us.</span><br><span class=\"line\">                //如果child的layout_wOrh属性在xml或者java中给予WRAP_CONTENT</span><br><span class=\"line\">                //设置child的size为size，mode为AT_MOST</span><br><span class=\"line\">                resultSize = size;</span><br><span class=\"line\">                resultMode = MeasureSpec.AT_MOST;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            break;</span><br><span class=\"line\"></span><br><span class=\"line\">        // Parent has imposed a maximum size on us</span><br><span class=\"line\">        case MeasureSpec.AT_MOST:</span><br><span class=\"line\">            if (childDimension &gt;= 0) &#123;</span><br><span class=\"line\">                // ......</span><br><span class=\"line\">            &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class=\"line\">                // Child wants to be our size, but our size is not fixed.</span><br><span class=\"line\">                // Constrain child to not be bigger than us.</span><br><span class=\"line\">                // 如果父 View 是 AT_MOST 就算子 View 是 MATCH_PARENT，</span><br><span class=\"line\">                // 其实子View获得的测量模式还是AT_MOST</span><br><span class=\"line\">                resultSize = size;</span><br><span class=\"line\">                resultMode = MeasureSpec.AT_MOST;</span><br><span class=\"line\">            &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class=\"line\">                // Child wants to determine its own size. It can&apos;t be</span><br><span class=\"line\">                // bigger than us.</span><br><span class=\"line\">                resultSize = size;</span><br><span class=\"line\">                resultMode = MeasureSpec.AT_MOST;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            break;</span><br><span class=\"line\"></span><br><span class=\"line\">            // ......</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        //noinspection ResourceType</span><br><span class=\"line\">        return MeasureSpec.makeMeasureSpec(resultSize, resultMode);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>View的绘制流程第一步是onMeasure()，该方法用来测量和指定布局到底占多大的宽高，因为控件的宽高是由父布局和本身来决定的，所以测量是不断的往内走，而最终确定宽高是由内不断的往外走，是递归的方式。</p>\n<ol start=\"2\">\n<li>performLayout</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void performLayout(WindowManager.LayoutParams lp, int desiredWindowWidth,</span><br><span class=\"line\">            int desiredWindowHeight) &#123;</span><br><span class=\"line\">        final View host = mView;</span><br><span class=\"line\">        // 调用layout()方法</span><br><span class=\"line\">        host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void layout(int l, int t, int r, int b) &#123;</span><br><span class=\"line\">        onLayout(changed, l, t, r, b);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">    protected void onLayout(boolean changed, int l, int t, int r, int b) &#123;</span><br><span class=\"line\">        if (mOrientation == VERTICAL) &#123;</span><br><span class=\"line\">            // 我们以垂直为例</span><br><span class=\"line\">            layoutVertical(l, t, r, b);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            layoutHorizontal(l, t, r, b);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void layoutVertical(int left, int top, int right, int bottom) &#123;</span><br><span class=\"line\">        final int paddingLeft = mPaddingLeft;</span><br><span class=\"line\"></span><br><span class=\"line\">        int childTop;</span><br><span class=\"line\">        int childLeft;</span><br><span class=\"line\"></span><br><span class=\"line\">        // Where right end of child should go</span><br><span class=\"line\">        //计算父窗口推荐的子View宽度</span><br><span class=\"line\">        final int width = right - left;</span><br><span class=\"line\">        //计算父窗口推荐的子View右侧位置</span><br><span class=\"line\">        int childRight = width - mPaddingRight;</span><br><span class=\"line\"></span><br><span class=\"line\">        // Space available for child</span><br><span class=\"line\">        //child可使用空间大小</span><br><span class=\"line\">        int childSpace = width - paddingLeft - mPaddingRight;</span><br><span class=\"line\">        //通过ViewGroup的getChildCount方法获取ViewGroup的子View个数</span><br><span class=\"line\">        final int count = getVirtualChildCount();</span><br><span class=\"line\">        //获取Gravity属性设置</span><br><span class=\"line\">        final int majorGravity = mGravity &amp; Gravity.VERTICAL_GRAVITY_MASK;</span><br><span class=\"line\">        final int minorGravity = mGravity &amp; Gravity.RELATIVE_HORIZONTAL_GRAVITY_MASK;</span><br><span class=\"line\">        //依据majorGravity计算childTop的位置值</span><br><span class=\"line\">        switch (majorGravity) &#123;</span><br><span class=\"line\">           case Gravity.BOTTOM:</span><br><span class=\"line\">               // mTotalLength contains the padding already</span><br><span class=\"line\">               childTop = mPaddingTop + bottom - top - mTotalLength;</span><br><span class=\"line\">               break;</span><br><span class=\"line\"></span><br><span class=\"line\">               // mTotalLength contains the padding already</span><br><span class=\"line\">           case Gravity.CENTER_VERTICAL:</span><br><span class=\"line\">               childTop = mPaddingTop + (bottom - top - mTotalLength) / 2;</span><br><span class=\"line\">               break;</span><br><span class=\"line\"></span><br><span class=\"line\">           case Gravity.TOP:</span><br><span class=\"line\">           default:</span><br><span class=\"line\">               childTop = mPaddingTop;</span><br><span class=\"line\">               break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        //重点！！！开始遍历</span><br><span class=\"line\">        for (int i = 0; i &lt; count; i++) &#123;</span><br><span class=\"line\">            final View child = getVirtualChildAt(i);</span><br><span class=\"line\">            if (child == null) &#123;</span><br><span class=\"line\">                childTop += measureNullChild(i);</span><br><span class=\"line\">            &#125; else if (child.getVisibility() != GONE) &#123;</span><br><span class=\"line\">                //LinearLayout中其子视图显示的宽和高由measure过程来决定的，因此measure过程的意义就是为layout过程提供视图显示范围的参考值</span><br><span class=\"line\">                final int childWidth = child.getMeasuredWidth();</span><br><span class=\"line\">                final int childHeight = child.getMeasuredHeight();</span><br><span class=\"line\">                //获取子View的LayoutParams</span><br><span class=\"line\">                final LinearLayout.LayoutParams lp =</span><br><span class=\"line\">                        (LinearLayout.LayoutParams) child.getLayoutParams();</span><br><span class=\"line\"></span><br><span class=\"line\">                int gravity = lp.gravity;</span><br><span class=\"line\">                if (gravity &lt; 0) &#123;</span><br><span class=\"line\">                    gravity = minorGravity;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                final int layoutDirection = getLayoutDirection();</span><br><span class=\"line\">                final int absoluteGravity = Gravity.getAbsoluteGravity(gravity, layoutDirection);</span><br><span class=\"line\">                //依据不同的absoluteGravity计算childLeft位置</span><br><span class=\"line\">                switch (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) &#123;</span><br><span class=\"line\">                    case Gravity.CENTER_HORIZONTAL:</span><br><span class=\"line\">                        childLeft = paddingLeft + ((childSpace - childWidth) / 2)</span><br><span class=\"line\">                                + lp.leftMargin - lp.rightMargin;</span><br><span class=\"line\">                        break;</span><br><span class=\"line\"></span><br><span class=\"line\">                    case Gravity.RIGHT:</span><br><span class=\"line\">                        childLeft = childRight - childWidth - lp.rightMargin;</span><br><span class=\"line\">                        break;</span><br><span class=\"line\"></span><br><span class=\"line\">                    case Gravity.LEFT:</span><br><span class=\"line\">                    default:</span><br><span class=\"line\">                        childLeft = paddingLeft + lp.leftMargin;</span><br><span class=\"line\">                        break;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                if (hasDividerBeforeChildAt(i)) &#123;</span><br><span class=\"line\">                    childTop += mDividerHeight;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                childTop += lp.topMargin;</span><br><span class=\"line\">                //通过垂直排列计算调运child的layout设置child的位置</span><br><span class=\"line\">                setChildFrame(child, childLeft, childTop + getLocationOffset(child),</span><br><span class=\"line\">                        childWidth, childHeight);</span><br><span class=\"line\">                childTop += childHeight + lp.bottomMargin + getNextLocationOffset(child);</span><br><span class=\"line\"></span><br><span class=\"line\">                i += getChildrenSkipCount(child, i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>从上面分析可以看出layout也是从顶层父View向子View的递归调用view.layout方法的过程，即父View根据第一步performMeasure，来获取子View所的布局大小和布局参数，将子View放在合适的位置上，不过这个方法没有再往外走，只是不断的往里面走。</p>\n<ol start=\"3\">\n<li>performDraw</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void performDraw() &#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            draw(fullRedrawNeeded);</span><br><span class=\"line\">        &#125; finally &#123;</span><br><span class=\"line\">            mIsDrawing = false;</span><br><span class=\"line\">            Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private void draw(boolean fullRedrawNeeded) &#123;</span><br><span class=\"line\">        Surface surface = mSurface;</span><br><span class=\"line\">        if (!surface.isValid()) &#123;</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        if (!drawSoftware(surface, mAttachInfo, xOffset, yOffset, scalingRequired, dirty)) &#123;</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private boolean drawSoftware(Surface surface, AttachInfo attachInfo, int xoff, int yoff,</span><br><span class=\"line\">            boolean scalingRequired, Rect dirty) &#123;</span><br><span class=\"line\">        // Draw with software renderer.</span><br><span class=\"line\">        final Canvas canvas;</span><br><span class=\"line\">        final int left = dirty.left;</span><br><span class=\"line\">        final int top = dirty.top;</span><br><span class=\"line\">        final int right = dirty.right;</span><br><span class=\"line\">        final int bottom = dirty.bottom;</span><br><span class=\"line\">        canvas = mSurface.lockCanvas(dirty);</span><br><span class=\"line\">        // ... ...</span><br><span class=\"line\">        mView.draw(canvas);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"事件分发\"><a href=\"#事件分发\" class=\"headerlink\" title=\"事件分发\"></a>事件分发</h4><ol>\n<li>事件类型(down,up,move,cancel),从手指借出屏幕到手指离开屏幕为一组事件<br><img src=\"https://coolyun1.oss-cn-shenzhen.aliyuncs.com/20190719141523.png\" alt></li>\n<li>事件分发的本质就是将点击事件传递到某个具体的view&amp;处理的整个过程.</li>\n<li>事件在Activity,ViewGroup,View中传递</li>\n<li>事件分发由哪些方法协作完成<br><img src=\"https://coolyun1.oss-cn-shenzhen.aliyuncs.com/20190719141541.png\" alt></li>\n<li>activity的事件分发:<br><img src=\"https://coolyun1.oss-cn-shenzhen.aliyuncs.com/20190719141600.png\" alt><br><img src=\"https://coolyun1.oss-cn-shenzhen.aliyuncs.com/20190719141630.png\" alt></li>\n<li>ViewGroup的事件分发:<br><img src=\"https://coolyun1.oss-cn-shenzhen.aliyuncs.com/20190719141645.png\" alt></li>\n<li>View的事件分发:<br><img src=\"https://coolyun1.oss-cn-shenzhen.aliyuncs.com/20190719141703.png\" alt><br><img src=\"https://coolyun1.oss-cn-shenzhen.aliyuncs.com/20190719141725.png\" alt></li>\n<li>总结<br><img src=\"https://coolyun1.oss-cn-shenzhen.aliyuncs.com/20190719141805.png\" alt></li>\n</ol>\n<h4 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h4><p>从Activity到ViewGroup到View. Activity类中添加一下代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">    public boolean onTouchEvent(MotionEvent event) &#123;</span><br><span class=\"line\">        Log.e(&quot;gao&quot;, &quot;onTouchEvent: &quot;+this.getClass().getName());</span><br><span class=\"line\">        return super.onTouchEvent(event);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void onClick(View v) &#123;</span><br><span class=\"line\">        Log.e(&quot;gao&quot;, &quot;onClick: &quot;+this.getClass().getName());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public boolean dispatchTouchEvent(MotionEvent ev) &#123;</span><br><span class=\"line\">        Log.e(&quot;gao&quot;, &quot;dispatchTouchEvent: &quot;+this.getClass().getName());</span><br><span class=\"line\">        return super.dispatchTouchEvent(ev);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p> ViewGroup中添加以下代码:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">    public boolean dispatchTouchEvent(MotionEvent ev) &#123;</span><br><span class=\"line\">        Log.e(&quot;gao&quot;, &quot;dispatchTouchEvent: &quot;+this.getClass().getName());</span><br><span class=\"line\">        return super.dispatchTouchEvent(ev);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public boolean onInterceptTouchEvent(MotionEvent ev) &#123;</span><br><span class=\"line\">        Log.e(&quot;gao&quot;, &quot;onInterceptTouchEvent: &quot;+this.getClass().getName());</span><br><span class=\"line\">        return super.onInterceptTouchEvent(ev);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public boolean onTouchEvent(MotionEvent event) &#123;</span><br><span class=\"line\">        Log.e(&quot;gao&quot;, &quot;onTouchEvent: &quot;+this.getClass().getName());</span><br><span class=\"line\">        return super.onTouchEvent(event);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>View中添加以下代码:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">    public boolean onTouchEvent(MotionEvent event) &#123;</span><br><span class=\"line\">        Log.e(&quot;gao&quot;, &quot;onTouchEvent: &quot;+this.getClass().getName());</span><br><span class=\"line\">        return super.onTouchEvent(event);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public boolean dispatchTouchEvent(MotionEvent event) &#123;</span><br><span class=\"line\">        Log.e(&quot;gao&quot;, &quot;dispatchTouchEvent: &quot;+this.getClass().getName());</span><br><span class=\"line\">        return super.dispatchTouchEvent(event);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>  默认情况下调用顺序:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">04-17 08:03:09.766 2887-2887/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class=\"line\">04-17 08:03:09.767 2887-2887/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 08:03:09.767 2887-2887/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 08:03:09.767 2887-2887/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn</span><br><span class=\"line\">04-17 08:03:09.767 2887-2887/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn</span><br><span class=\"line\">04-17 08:03:09.786 2887-2887/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 08:03:09.786 2887-2887/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class=\"line\">04-17 08:03:09.889 2887-2887/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class=\"line\">04-17 08:03:09.889 2887-2887/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br></pre></td></tr></table></figure>\n\n<p>view中touchEvent改为true</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">04-17 08:06:14.757 2992-2992/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class=\"line\">04-17 08:06:14.757 2992-2992/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 08:06:14.757 2992-2992/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 08:06:14.757 2992-2992/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn</span><br><span class=\"line\">04-17 08:06:14.757 2992-2992/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn</span><br><span class=\"line\">04-17 08:06:14.757 2992-2992/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class=\"line\">04-17 08:06:14.757 2992-2992/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 08:06:14.757 2992-2992/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 08:06:14.757 2992-2992/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn</span><br><span class=\"line\">04-17 08:06:14.757 2992-2992/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn</span><br></pre></td></tr></table></figure>\n\n<p>事件传到View后不再往外传,因为已经被消费了 方法都调用了两遍是因为接收了down事件之后,up事件也传过来接收了</p>\n<p>view中touchEvent改为false</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">04-17 08:23:47.369 3622-3622/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class=\"line\">04-17 08:23:47.370 3622-3622/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 08:23:47.370 3622-3622/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 08:23:47.370 3622-3622/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn</span><br><span class=\"line\">04-17 08:23:47.370 3622-3622/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn</span><br><span class=\"line\">04-17 08:23:47.370 3622-3622/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 08:23:47.370 3622-3622/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class=\"line\">04-17 08:23:47.505 3622-3622/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class=\"line\">04-17 08:23:47.505 3622-3622/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br></pre></td></tr></table></figure>\n\n<p>View的dispatchTouchEvent改为true</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">04-17 08:26:52.930 3721-3721/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class=\"line\">04-17 08:26:52.930 3721-3721/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 08:26:52.930 3721-3721/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 08:26:52.930 3721-3721/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn</span><br></pre></td></tr></table></figure>\n\n<p>不再分发,不消费,会接收后续事件</p>\n<p>View的dispatchTouchEvent改为false</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">04-17 08:29:02.066 3822-3822/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class=\"line\">04-17 08:29:02.067 3822-3822/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 08:29:02.067 3822-3822/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 08:29:02.067 3822-3822/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn</span><br><span class=\"line\">04-17 08:29:02.067 3822-3822/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 08:29:02.067 3822-3822/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class=\"line\">04-17 08:29:02.176 3822-3822/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class=\"line\">04-17 08:29:02.176 3822-3822/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br></pre></td></tr></table></figure>\n\n<p>不再分发.会传给外层布局的onTouchEvent进行消费,如果都不进行消费,则后续事件不再向内分发.</p>\n<p>只有View的dispatchTouchEvent为默认值时才会调View的onTouchEvent方法.</p>\n<p>ViewGroup中</p>\n<p>onTouchEvent返回true</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">04-17 08:42:18.120 4533-4533/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class=\"line\">04-17 08:42:18.121 4533-4533/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 08:42:18.121 4533-4533/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 08:42:18.122 4533-4533/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn</span><br><span class=\"line\">04-17 08:42:18.122 4533-4533/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn</span><br><span class=\"line\">04-17 08:42:18.122 4533-4533/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 08:42:35.925 4533-4533/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class=\"line\">04-17 08:42:35.925 4533-4533/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 08:42:35.925 4533-4533/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br></pre></td></tr></table></figure>\n\n<p>消费之后会仍会分发给子类,如果子类不消费,后续事件不再分发给子类.</p>\n<p>于此同时把View的onTouchEvent方法改为true</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">04-17 08:44:28.544 4635-4635/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class=\"line\">04-17 08:44:28.545 4635-4635/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 08:44:28.545 4635-4635/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 08:44:28.545 4635-4635/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn</span><br><span class=\"line\">04-17 08:44:28.545 4635-4635/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn</span><br><span class=\"line\">04-17 08:44:34.966 4635-4635/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class=\"line\">04-17 08:44:34.966 4635-4635/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 08:44:34.966 4635-4635/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 08:44:34.966 4635-4635/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn</span><br><span class=\"line\">04-17 08:44:34.966 4635-4635/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn</span><br></pre></td></tr></table></figure>\n\n<p>对ViewGroup的事件消费,且后续事件会传递到View中.</p>\n<p>onTouchEvent返回false</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">04-17 08:46:36.068 4735-4735/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class=\"line\">04-17 08:46:36.068 4735-4735/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 08:46:36.068 4735-4735/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 08:46:36.068 4735-4735/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn</span><br><span class=\"line\">04-17 08:46:36.068 4735-4735/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn</span><br><span class=\"line\">04-17 08:46:36.068 4735-4735/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 08:46:36.068 4735-4735/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class=\"line\">04-17 08:47:04.229 4735-4735/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class=\"line\">04-17 08:47:04.229 4735-4735/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br></pre></td></tr></table></figure>\n\n<p>不进行消费,当次事件会继续分发,如果子View不进行消费则后续事件不再分发进ViewGroup,如果子View进行消费,则后续事件仍会分发,只是不再经过ViewGroup的OntouchEvent()</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">04-17 08:50:15.560 5023-5023/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class=\"line\">04-17 08:50:15.560 5023-5023/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 08:50:15.560 5023-5023/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 08:50:15.560 5023-5023/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn</span><br><span class=\"line\">04-17 08:50:15.560 5023-5023/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn</span><br><span class=\"line\">04-17 08:50:19.491 5023-5023/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class=\"line\">04-17 08:50:19.491 5023-5023/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 08:50:19.491 5023-5023/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 08:50:19.491 5023-5023/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn</span><br><span class=\"line\">04-17 08:50:19.491 5023-5023/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn</span><br></pre></td></tr></table></figure>\n\n<p>onInterceptTouchEvent返回true</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">04-17 08:53:53.191 5127-5127/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class=\"line\">04-17 08:53:53.193 5127-5127/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 08:53:53.193 5127-5127/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 08:53:53.193 5127-5127/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 08:53:53.193 5127-5127/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class=\"line\">04-17 08:54:08.389 5127-5127/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class=\"line\">04-17 08:54:08.389 5127-5127/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br></pre></td></tr></table></figure>\n\n<p>拦截后事件不会据需分发,会调用ViewGroup的OntouchVent,如果不进行消费,后续事件不会分发进来.</p>\n<p>与此同时,把onTOuchEvent的返回值改为true</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">04-17 08:56:00.350 5228-5228/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class=\"line\">04-17 08:56:00.350 5228-5228/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 08:56:00.350 5228-5228/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 08:56:00.351 5228-5228/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 08:56:02.535 5228-5228/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class=\"line\">04-17 08:56:02.535 5228-5228/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 08:56:02.535 5228-5228/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br></pre></td></tr></table></figure>\n\n<p>拦截之后进行消费,后续事件仍会继续分发,但不再调用拦截方法</p>\n<p>把dispatchTouchEvent返回true</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">04-17 09:00:31.695 5428-5428/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class=\"line\">04-17 09:00:31.695 5428-5428/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 09:00:31.813 5428-5428/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class=\"line\">04-17 09:00:31.814 5428-5428/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br></pre></td></tr></table></figure>\n\n<p>往外分发,仍接收后续事件 改为false</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">04-17 09:02:19.810 5529-5529/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class=\"line\">04-17 09:02:19.810 5529-5529/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 09:02:19.810 5529-5529/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class=\"line\">04-17 09:02:19.928 5529-5529/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class=\"line\">04-17 09:02:19.928 5529-5529/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br></pre></td></tr></table></figure>\n\n<p>向外分发,不再接收后续事件,会调用Activity的onTouchEvent()</p>\n<p>Activity中</p>\n<p>dispatchTouchEvent返回true或false</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">04-17 09:08:04.216 5728-5728/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class=\"line\">04-17 09:08:04.333 5728-5728/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br></pre></td></tr></table></figure>\n\n<p>onTouchEvent()改为true</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">04-17 09:09:23.950 5931-5931/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class=\"line\">04-17 09:09:23.950 5931-5931/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 09:09:23.951 5931-5931/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 09:09:23.951 5931-5931/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn</span><br><span class=\"line\">04-17 09:09:23.951 5931-5931/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn</span><br><span class=\"line\">04-17 09:09:23.951 5931-5931/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 09:09:23.951 5931-5931/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class=\"line\">04-17 09:09:24.094 5931-5931/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class=\"line\">04-17 09:09:24.094 5931-5931/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br></pre></td></tr></table></figure>\n\n<p>当次事件会继续分发,如果没有子控件消费,后续事件不再分发.直接调用onTouchEvent,</p>\n<p>于此同时把View中的onTouchEvent方法返回true</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">04-17 09:15:08.467 6031-6031/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class=\"line\">04-17 09:15:08.467 6031-6031/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 09:15:08.467 6031-6031/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 09:15:08.467 6031-6031/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn</span><br><span class=\"line\">04-17 09:15:08.467 6031-6031/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn</span><br><span class=\"line\">04-17 09:15:11.154 6031-6031/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.Main3Activity</span><br><span class=\"line\">04-17 09:15:11.154 6031-6031/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 09:15:11.154 6031-6031/zhuiyun.xyz.studypro E/gao: onInterceptTouchEvent: zhuiyun.xyz.studypro.MyRela</span><br><span class=\"line\">04-17 09:15:11.154 6031-6031/zhuiyun.xyz.studypro E/gao: dispatchTouchEvent: zhuiyun.xyz.studypro.MyBtn</span><br><span class=\"line\">04-17 09:15:11.154 6031-6031/zhuiyun.xyz.studypro E/gao: onTouchEvent: zhuiyun.xyz.studypro.MyBtn</span><br></pre></td></tr></table></figure>\n\n<p>View会先于Activity消费事件,且后续事件会继续分发到View</p>\n<p>把Activity的onTouchEvent()置为false,且子类不消费事件,则当次事件继续分发,后续事件不再分发,直接调用Activity的onTouchEvent方法.</p>\n<h4 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h4><p><a href=\"https://www.jianshu.com/p/1075d7d521ec\" target=\"_blank\" rel=\"noopener\">源码解析 - View的绘制流程</a><br><a href=\"https://www.jianshu.com/p/56006bc13dcf\" target=\"_blank\" rel=\"noopener\">Android 自定义View——View的绘制流程</a><br><a href=\"https://www.jianshu.com/p/38015afcdb58\" target=\"_blank\" rel=\"noopener\">Android事件分发机制详解：史上最全面、最易懂</a></p>"}],"PostAsset":[],"PostCategory":[{"post_id":"ck03xfcal00084frr839cv9sb","category_id":"ck03xfcah00044frr24rapgjr","_id":"ck03xfcan000b4frr40etrrtr"},{"post_id":"ck03xfcaa00014frr37z3ekoj","category_id":"ck03xfcah00044frr24rapgjr","_id":"ck03xfcao000d4frrv5ntktoi"},{"post_id":"ck03xfcaf00034frr2firrwz3","category_id":"ck03xfcah00044frr24rapgjr","_id":"ck03xfcao000f4frrxabc078t"},{"post_id":"ck03xfcbd000n4frrc9gjlbfw","category_id":"ck03xfcah00044frr24rapgjr","_id":"ck03xfcbe000q4frrhv7iulri"}],"PostTag":[{"post_id":"ck03xfcaa00014frr37z3ekoj","tag_id":"ck03xfcai00054frrxdywbv9h","_id":"ck03xfcao000e4frrzofy2630"},{"post_id":"ck03xfcaa00014frr37z3ekoj","tag_id":"ck03xfcam000a4frrf9kxsqvk","_id":"ck03xfcao000g4frrfsrtqwhf"},{"post_id":"ck03xfcaf00034frr2firrwz3","tag_id":"ck03xfcai00054frrxdywbv9h","_id":"ck03xfcap000j4frrqasi0jbx"},{"post_id":"ck03xfcaf00034frr2firrwz3","tag_id":"ck03xfcao000h4frrfjc75nip","_id":"ck03xfcap000k4frrfsnqgo5x"},{"post_id":"ck03xfcal00084frr839cv9sb","tag_id":"ck03xfcai00054frrxdywbv9h","_id":"ck03xfcap000l4frrv4zn9mft"},{"post_id":"ck03xfcal00084frr839cv9sb","tag_id":"ck03xfcap000i4frr71frp4q7","_id":"ck03xfcap000m4frrhgqx04ca"},{"post_id":"ck03xfcbd000n4frrc9gjlbfw","tag_id":"ck03xfcai00054frrxdywbv9h","_id":"ck03xfcbe000o4frrzja8bp06"},{"post_id":"ck03xfcbd000n4frrc9gjlbfw","tag_id":"ck03xfcap000i4frr71frp4q7","_id":"ck03xfcbe000p4frrugr787xu"}],"Tag":[{"name":"Android","_id":"ck03xfcai00054frrxdywbv9h"},{"name":"问题解决","_id":"ck03xfcam000a4frrf9kxsqvk"},{"name":"源码","_id":"ck03xfcao000h4frrfjc75nip"},{"name":"面试","_id":"ck03xfcap000i4frr71frp4q7"}]}}